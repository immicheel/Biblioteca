[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/angular_angular-animate/angular-animate.js                                                                 //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/**                                                                                                                    // 1\n * @license AngularJS v1.5.3                                                                                           // 2\n * (c) 2010-2016 Google, Inc. http://angularjs.org                                                                     // 3\n * License: MIT                                                                                                        // 4\n */                                                                                                                    // 5\n(function(window, angular, undefined) {'use strict';                                                                   // 6\n                                                                                                                       // 7\n/* jshint ignore:start */                                                                                              // 8\nvar noop        = angular.noop;                                                                                        // 9\nvar copy        = angular.copy;                                                                                        // 10\nvar extend      = angular.extend;                                                                                      // 11\nvar jqLite      = angular.element;                                                                                     // 12\nvar forEach     = angular.forEach;                                                                                     // 13\nvar isArray     = angular.isArray;                                                                                     // 14\nvar isString    = angular.isString;                                                                                    // 15\nvar isObject    = angular.isObject;                                                                                    // 16\nvar isUndefined = angular.isUndefined;                                                                                 // 17\nvar isDefined   = angular.isDefined;                                                                                   // 18\nvar isFunction  = angular.isFunction;                                                                                  // 19\nvar isElement   = angular.isElement;                                                                                   // 20\n                                                                                                                       // 21\nvar ELEMENT_NODE = 1;                                                                                                  // 22\nvar COMMENT_NODE = 8;                                                                                                  // 23\n                                                                                                                       // 24\nvar ADD_CLASS_SUFFIX = '-add';                                                                                         // 25\nvar REMOVE_CLASS_SUFFIX = '-remove';                                                                                   // 26\nvar EVENT_CLASS_PREFIX = 'ng-';                                                                                        // 27\nvar ACTIVE_CLASS_SUFFIX = '-active';                                                                                   // 28\nvar PREPARE_CLASS_SUFFIX = '-prepare';                                                                                 // 29\n                                                                                                                       // 30\nvar NG_ANIMATE_CLASSNAME = 'ng-animate';                                                                               // 31\nvar NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';                                                                  // 32\n                                                                                                                       // 33\n// Detect proper transitionend/animationend event names.                                                               // 34\nvar CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;                         // 35\n                                                                                                                       // 36\n// If unprefixed events are not supported but webkit-prefixed are, use the latter.                                     // 37\n// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.                           // 38\n// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`                 // 39\n// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.                              // 40\n// Register both events in case `window.onanimationend` is not supported because of that,                              // 41\n// do the same for `transitionend` as Safari is likely to exhibit similar behavior.                                    // 42\n// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit                         // 43\n// therefore there is no reason to test anymore for other vendor prefixes:                                             // 44\n// http://caniuse.com/#search=transition                                                                               // 45\nif (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {                                  // 46\n  CSS_PREFIX = '-webkit-';                                                                                             // 47\n  TRANSITION_PROP = 'WebkitTransition';                                                                                // 48\n  TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';                                                           // 49\n} else {                                                                                                               // 50\n  TRANSITION_PROP = 'transition';                                                                                      // 51\n  TRANSITIONEND_EVENT = 'transitionend';                                                                               // 52\n}                                                                                                                      // 53\n                                                                                                                       // 54\nif (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {                                    // 55\n  CSS_PREFIX = '-webkit-';                                                                                             // 56\n  ANIMATION_PROP = 'WebkitAnimation';                                                                                  // 57\n  ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';                                                              // 58\n} else {                                                                                                               // 59\n  ANIMATION_PROP = 'animation';                                                                                        // 60\n  ANIMATIONEND_EVENT = 'animationend';                                                                                 // 61\n}                                                                                                                      // 62\n                                                                                                                       // 63\nvar DURATION_KEY = 'Duration';                                                                                         // 64\nvar PROPERTY_KEY = 'Property';                                                                                         // 65\nvar DELAY_KEY = 'Delay';                                                                                               // 66\nvar TIMING_KEY = 'TimingFunction';                                                                                     // 67\nvar ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';                                                                  // 68\nvar ANIMATION_PLAYSTATE_KEY = 'PlayState';                                                                             // 69\nvar SAFE_FAST_FORWARD_DURATION_VALUE = 9999;                                                                           // 70\n                                                                                                                       // 71\nvar ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;                                                                 // 72\nvar ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;                                                           // 73\nvar TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;                                                               // 74\nvar TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;                                                         // 75\n                                                                                                                       // 76\nvar isPromiseLike = function(p) {                                                                                      // 77\n  return p && p.then ? true : false;                                                                                   // 78\n};                                                                                                                     // 79\n                                                                                                                       // 80\nvar ngMinErr = angular.$$minErr('ng');                                                                                 // 81\nfunction assertArg(arg, name, reason) {                                                                                // 82\n  if (!arg) {                                                                                                          // 83\n    throw ngMinErr('areq', \"Argument '{0}' is {1}\", (name || '?'), (reason || \"required\"));                            // 84\n  }                                                                                                                    // 85\n  return arg;                                                                                                          // 86\n}                                                                                                                      // 87\n                                                                                                                       // 88\nfunction mergeClasses(a,b) {                                                                                           // 89\n  if (!a && !b) return '';                                                                                             // 90\n  if (!a) return b;                                                                                                    // 91\n  if (!b) return a;                                                                                                    // 92\n  if (isArray(a)) a = a.join(' ');                                                                                     // 93\n  if (isArray(b)) b = b.join(' ');                                                                                     // 94\n  return a + ' ' + b;                                                                                                  // 95\n}                                                                                                                      // 96\n                                                                                                                       // 97\nfunction packageStyles(options) {                                                                                      // 98\n  var styles = {};                                                                                                     // 99\n  if (options && (options.to || options.from)) {                                                                       // 100\n    styles.to = options.to;                                                                                            // 101\n    styles.from = options.from;                                                                                        // 102\n  }                                                                                                                    // 103\n  return styles;                                                                                                       // 104\n}                                                                                                                      // 105\n                                                                                                                       // 106\nfunction pendClasses(classes, fix, isPrefix) {                                                                         // 107\n  var className = '';                                                                                                  // 108\n  classes = isArray(classes)                                                                                           // 109\n      ? classes                                                                                                        // 110\n      : classes && isString(classes) && classes.length                                                                 // 111\n          ? classes.split(/\\s+/)                                                                                       // 112\n          : [];                                                                                                        // 113\n  forEach(classes, function(klass, i) {                                                                                // 114\n    if (klass && klass.length > 0) {                                                                                   // 115\n      className += (i > 0) ? ' ' : '';                                                                                 // 116\n      className += isPrefix ? fix + klass                                                                              // 117\n                            : klass + fix;                                                                             // 118\n    }                                                                                                                  // 119\n  });                                                                                                                  // 120\n  return className;                                                                                                    // 121\n}                                                                                                                      // 122\n                                                                                                                       // 123\nfunction removeFromArray(arr, val) {                                                                                   // 124\n  var index = arr.indexOf(val);                                                                                        // 125\n  if (val >= 0) {                                                                                                      // 126\n    arr.splice(index, 1);                                                                                              // 127\n  }                                                                                                                    // 128\n}                                                                                                                      // 129\n                                                                                                                       // 130\nfunction stripCommentsFromElement(element) {                                                                           // 131\n  if (element instanceof jqLite) {                                                                                     // 132\n    switch (element.length) {                                                                                          // 133\n      case 0:                                                                                                          // 134\n        return [];                                                                                                     // 135\n        break;                                                                                                         // 136\n                                                                                                                       // 137\n      case 1:                                                                                                          // 138\n        // there is no point of stripping anything if the element                                                      // 139\n        // is the only element within the jqLite wrapper.                                                              // 140\n        // (it's important that we retain the element instance.)                                                       // 141\n        if (element[0].nodeType === ELEMENT_NODE) {                                                                    // 142\n          return element;                                                                                              // 143\n        }                                                                                                              // 144\n        break;                                                                                                         // 145\n                                                                                                                       // 146\n      default:                                                                                                         // 147\n        return jqLite(extractElementNode(element));                                                                    // 148\n        break;                                                                                                         // 149\n    }                                                                                                                  // 150\n  }                                                                                                                    // 151\n                                                                                                                       // 152\n  if (element.nodeType === ELEMENT_NODE) {                                                                             // 153\n    return jqLite(element);                                                                                            // 154\n  }                                                                                                                    // 155\n}                                                                                                                      // 156\n                                                                                                                       // 157\nfunction extractElementNode(element) {                                                                                 // 158\n  if (!element[0]) return element;                                                                                     // 159\n  for (var i = 0; i < element.length; i++) {                                                                           // 160\n    var elm = element[i];                                                                                              // 161\n    if (elm.nodeType == ELEMENT_NODE) {                                                                                // 162\n      return elm;                                                                                                      // 163\n    }                                                                                                                  // 164\n  }                                                                                                                    // 165\n}                                                                                                                      // 166\n                                                                                                                       // 167\nfunction $$addClass($$jqLite, element, className) {                                                                    // 168\n  forEach(element, function(elm) {                                                                                     // 169\n    $$jqLite.addClass(elm, className);                                                                                 // 170\n  });                                                                                                                  // 171\n}                                                                                                                      // 172\n                                                                                                                       // 173\nfunction $$removeClass($$jqLite, element, className) {                                                                 // 174\n  forEach(element, function(elm) {                                                                                     // 175\n    $$jqLite.removeClass(elm, className);                                                                              // 176\n  });                                                                                                                  // 177\n}                                                                                                                      // 178\n                                                                                                                       // 179\nfunction applyAnimationClassesFactory($$jqLite) {                                                                      // 180\n  return function(element, options) {                                                                                  // 181\n    if (options.addClass) {                                                                                            // 182\n      $$addClass($$jqLite, element, options.addClass);                                                                 // 183\n      options.addClass = null;                                                                                         // 184\n    }                                                                                                                  // 185\n    if (options.removeClass) {                                                                                         // 186\n      $$removeClass($$jqLite, element, options.removeClass);                                                           // 187\n      options.removeClass = null;                                                                                      // 188\n    }                                                                                                                  // 189\n  }                                                                                                                    // 190\n}                                                                                                                      // 191\n                                                                                                                       // 192\nfunction prepareAnimationOptions(options) {                                                                            // 193\n  options = options || {};                                                                                             // 194\n  if (!options.$$prepared) {                                                                                           // 195\n    var domOperation = options.domOperation || noop;                                                                   // 196\n    options.domOperation = function() {                                                                                // 197\n      options.$$domOperationFired = true;                                                                              // 198\n      domOperation();                                                                                                  // 199\n      domOperation = noop;                                                                                             // 200\n    };                                                                                                                 // 201\n    options.$$prepared = true;                                                                                         // 202\n  }                                                                                                                    // 203\n  return options;                                                                                                      // 204\n}                                                                                                                      // 205\n                                                                                                                       // 206\nfunction applyAnimationStyles(element, options) {                                                                      // 207\n  applyAnimationFromStyles(element, options);                                                                          // 208\n  applyAnimationToStyles(element, options);                                                                            // 209\n}                                                                                                                      // 210\n                                                                                                                       // 211\nfunction applyAnimationFromStyles(element, options) {                                                                  // 212\n  if (options.from) {                                                                                                  // 213\n    element.css(options.from);                                                                                         // 214\n    options.from = null;                                                                                               // 215\n  }                                                                                                                    // 216\n}                                                                                                                      // 217\n                                                                                                                       // 218\nfunction applyAnimationToStyles(element, options) {                                                                    // 219\n  if (options.to) {                                                                                                    // 220\n    element.css(options.to);                                                                                           // 221\n    options.to = null;                                                                                                 // 222\n  }                                                                                                                    // 223\n}                                                                                                                      // 224\n                                                                                                                       // 225\nfunction mergeAnimationDetails(element, oldAnimation, newAnimation) {                                                  // 226\n  var target = oldAnimation.options || {};                                                                             // 227\n  var newOptions = newAnimation.options || {};                                                                         // 228\n                                                                                                                       // 229\n  var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');                                             // 230\n  var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');                                    // 231\n  var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);                                         // 232\n                                                                                                                       // 233\n  if (newOptions.preparationClasses) {                                                                                 // 234\n    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);             // 235\n    delete newOptions.preparationClasses;                                                                              // 236\n  }                                                                                                                    // 237\n                                                                                                                       // 238\n  // noop is basically when there is no callback; otherwise something has been set                                     // 239\n  var realDomOperation = target.domOperation !== noop ? target.domOperation : null;                                    // 240\n                                                                                                                       // 241\n  extend(target, newOptions);                                                                                          // 242\n                                                                                                                       // 243\n  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.\n  if (realDomOperation) {                                                                                              // 245\n    target.domOperation = realDomOperation;                                                                            // 246\n  }                                                                                                                    // 247\n                                                                                                                       // 248\n  if (classes.addClass) {                                                                                              // 249\n    target.addClass = classes.addClass;                                                                                // 250\n  } else {                                                                                                             // 251\n    target.addClass = null;                                                                                            // 252\n  }                                                                                                                    // 253\n                                                                                                                       // 254\n  if (classes.removeClass) {                                                                                           // 255\n    target.removeClass = classes.removeClass;                                                                          // 256\n  } else {                                                                                                             // 257\n    target.removeClass = null;                                                                                         // 258\n  }                                                                                                                    // 259\n                                                                                                                       // 260\n  oldAnimation.addClass = target.addClass;                                                                             // 261\n  oldAnimation.removeClass = target.removeClass;                                                                       // 262\n                                                                                                                       // 263\n  return target;                                                                                                       // 264\n}                                                                                                                      // 265\n                                                                                                                       // 266\nfunction resolveElementClasses(existing, toAdd, toRemove) {                                                            // 267\n  var ADD_CLASS = 1;                                                                                                   // 268\n  var REMOVE_CLASS = -1;                                                                                               // 269\n                                                                                                                       // 270\n  var flags = {};                                                                                                      // 271\n  existing = splitClassesToLookup(existing);                                                                           // 272\n                                                                                                                       // 273\n  toAdd = splitClassesToLookup(toAdd);                                                                                 // 274\n  forEach(toAdd, function(value, key) {                                                                                // 275\n    flags[key] = ADD_CLASS;                                                                                            // 276\n  });                                                                                                                  // 277\n                                                                                                                       // 278\n  toRemove = splitClassesToLookup(toRemove);                                                                           // 279\n  forEach(toRemove, function(value, key) {                                                                             // 280\n    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;                                                       // 281\n  });                                                                                                                  // 282\n                                                                                                                       // 283\n  var classes = {                                                                                                      // 284\n    addClass: '',                                                                                                      // 285\n    removeClass: ''                                                                                                    // 286\n  };                                                                                                                   // 287\n                                                                                                                       // 288\n  forEach(flags, function(val, klass) {                                                                                // 289\n    var prop, allow;                                                                                                   // 290\n    if (val === ADD_CLASS) {                                                                                           // 291\n      prop = 'addClass';                                                                                               // 292\n      allow = !existing[klass];                                                                                        // 293\n    } else if (val === REMOVE_CLASS) {                                                                                 // 294\n      prop = 'removeClass';                                                                                            // 295\n      allow = existing[klass];                                                                                         // 296\n    }                                                                                                                  // 297\n    if (allow) {                                                                                                       // 298\n      if (classes[prop].length) {                                                                                      // 299\n        classes[prop] += ' ';                                                                                          // 300\n      }                                                                                                                // 301\n      classes[prop] += klass;                                                                                          // 302\n    }                                                                                                                  // 303\n  });                                                                                                                  // 304\n                                                                                                                       // 305\n  function splitClassesToLookup(classes) {                                                                             // 306\n    if (isString(classes)) {                                                                                           // 307\n      classes = classes.split(' ');                                                                                    // 308\n    }                                                                                                                  // 309\n                                                                                                                       // 310\n    var obj = {};                                                                                                      // 311\n    forEach(classes, function(klass) {                                                                                 // 312\n      // sometimes the split leaves empty string values                                                                // 313\n      // incase extra spaces were applied to the options                                                               // 314\n      if (klass.length) {                                                                                              // 315\n        obj[klass] = true;                                                                                             // 316\n      }                                                                                                                // 317\n    });                                                                                                                // 318\n    return obj;                                                                                                        // 319\n  }                                                                                                                    // 320\n                                                                                                                       // 321\n  return classes;                                                                                                      // 322\n}                                                                                                                      // 323\n                                                                                                                       // 324\nfunction getDomNode(element) {                                                                                         // 325\n  return (element instanceof angular.element) ? element[0] : element;                                                  // 326\n}                                                                                                                      // 327\n                                                                                                                       // 328\nfunction applyGeneratedPreparationClasses(element, event, options) {                                                   // 329\n  var classes = '';                                                                                                    // 330\n  if (event) {                                                                                                         // 331\n    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);                                                            // 332\n  }                                                                                                                    // 333\n  if (options.addClass) {                                                                                              // 334\n    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));                               // 335\n  }                                                                                                                    // 336\n  if (options.removeClass) {                                                                                           // 337\n    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));                         // 338\n  }                                                                                                                    // 339\n  if (classes.length) {                                                                                                // 340\n    options.preparationClasses = classes;                                                                              // 341\n    element.addClass(classes);                                                                                         // 342\n  }                                                                                                                    // 343\n}                                                                                                                      // 344\n                                                                                                                       // 345\nfunction clearGeneratedClasses(element, options) {                                                                     // 346\n  if (options.preparationClasses) {                                                                                    // 347\n    element.removeClass(options.preparationClasses);                                                                   // 348\n    options.preparationClasses = null;                                                                                 // 349\n  }                                                                                                                    // 350\n  if (options.activeClasses) {                                                                                         // 351\n    element.removeClass(options.activeClasses);                                                                        // 352\n    options.activeClasses = null;                                                                                      // 353\n  }                                                                                                                    // 354\n}                                                                                                                      // 355\n                                                                                                                       // 356\nfunction blockTransitions(node, duration) {                                                                            // 357\n  // we use a negative delay value since it performs blocking                                                          // 358\n  // yet it doesn't kill any existing transitions running on the                                                       // 359\n  // same element which makes this safe for class-based animations                                                     // 360\n  var value = duration ? '-' + duration + 's' : '';                                                                    // 361\n  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);                                                              // 362\n  return [TRANSITION_DELAY_PROP, value];                                                                               // 363\n}                                                                                                                      // 364\n                                                                                                                       // 365\nfunction blockKeyframeAnimations(node, applyBlock) {                                                                   // 366\n  var value = applyBlock ? 'paused' : '';                                                                              // 367\n  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;                                                                  // 368\n  applyInlineStyle(node, [key, value]);                                                                                // 369\n  return [key, value];                                                                                                 // 370\n}                                                                                                                      // 371\n                                                                                                                       // 372\nfunction applyInlineStyle(node, styleTuple) {                                                                          // 373\n  var prop = styleTuple[0];                                                                                            // 374\n  var value = styleTuple[1];                                                                                           // 375\n  node.style[prop] = value;                                                                                            // 376\n}                                                                                                                      // 377\n                                                                                                                       // 378\nfunction concatWithSpace(a,b) {                                                                                        // 379\n  if (!a) return b;                                                                                                    // 380\n  if (!b) return a;                                                                                                    // 381\n  return a + ' ' + b;                                                                                                  // 382\n}                                                                                                                      // 383\n                                                                                                                       // 384\nvar $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {                                                                // 385\n  var queue, cancelFn;                                                                                                 // 386\n                                                                                                                       // 387\n  function scheduler(tasks) {                                                                                          // 388\n    // we make a copy since RAFScheduler mutates the state                                                             // 389\n    // of the passed in array variable and this would be difficult                                                     // 390\n    // to track down on the outside code                                                                               // 391\n    queue = queue.concat(tasks);                                                                                       // 392\n    nextTick();                                                                                                        // 393\n  }                                                                                                                    // 394\n                                                                                                                       // 395\n  queue = scheduler.queue = [];                                                                                        // 396\n                                                                                                                       // 397\n  /* waitUntilQuiet does two things:                                                                                   // 398\n   * 1. It will run the FINAL `fn` value only when an uncanceled RAF has passed through                                // 399\n   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.                                // 400\n   *                                                                                                                   // 401\n   * The motivation here is that animation code can request more time from the scheduler                               // 402\n   * before the next wave runs. This allows for certain DOM properties such as classes to                              // 403\n   * be resolved in time for the next animation to run.                                                                // 404\n   */                                                                                                                  // 405\n  scheduler.waitUntilQuiet = function(fn) {                                                                            // 406\n    if (cancelFn) cancelFn();                                                                                          // 407\n                                                                                                                       // 408\n    cancelFn = $$rAF(function() {                                                                                      // 409\n      cancelFn = null;                                                                                                 // 410\n      fn();                                                                                                            // 411\n      nextTick();                                                                                                      // 412\n    });                                                                                                                // 413\n  };                                                                                                                   // 414\n                                                                                                                       // 415\n  return scheduler;                                                                                                    // 416\n                                                                                                                       // 417\n  function nextTick() {                                                                                                // 418\n    if (!queue.length) return;                                                                                         // 419\n                                                                                                                       // 420\n    var items = queue.shift();                                                                                         // 421\n    for (var i = 0; i < items.length; i++) {                                                                           // 422\n      items[i]();                                                                                                      // 423\n    }                                                                                                                  // 424\n                                                                                                                       // 425\n    if (!cancelFn) {                                                                                                   // 426\n      $$rAF(function() {                                                                                               // 427\n        if (!cancelFn) nextTick();                                                                                     // 428\n      });                                                                                                              // 429\n    }                                                                                                                  // 430\n  }                                                                                                                    // 431\n}];                                                                                                                    // 432\n                                                                                                                       // 433\n/**                                                                                                                    // 434\n * @ngdoc directive                                                                                                    // 435\n * @name ngAnimateChildren                                                                                             // 436\n * @restrict AE                                                                                                        // 437\n * @element ANY                                                                                                        // 438\n *                                                                                                                     // 439\n * @description                                                                                                        // 440\n *                                                                                                                     // 441\n * ngAnimateChildren allows you to specify that children of this element should animate even if any                    // 442\n * of the children's parents are currently animating. By default, when an element has an active `enter`, `leave`, or `move`\n * (structural) animation, child elements that also have an active structural animation are not animated.              // 444\n *                                                                                                                     // 445\n * Note that even if `ngAnimteChildren` is set, no child animations will run when the parent element is removed from the DOM (`leave` animation).\n *                                                                                                                     // 447\n *                                                                                                                     // 448\n * @param {string} ngAnimateChildren If the value is empty, `true` or `on`,                                            // 449\n *     then child animations are allowed. If the value is `false`, child animations are not allowed.                   // 450\n *                                                                                                                     // 451\n * @example                                                                                                            // 452\n * <example module=\"ngAnimateChildren\" name=\"ngAnimateChildren\" deps=\"angular-animate.js\" animations=\"true\">           // 453\n     <file name=\"index.html\">                                                                                          // 454\n       <div ng-controller=\"mainController as main\">                                                                    // 455\n         <label>Show container? <input type=\"checkbox\" ng-model=\"main.enterElement\" /></label>                         // 456\n         <label>Animate children? <input type=\"checkbox\" ng-model=\"main.animateChildren\" /></label>                    // 457\n         <hr>                                                                                                          // 458\n         <div ng-animate-children=\"{{main.animateChildren}}\">                                                          // 459\n           <div ng-if=\"main.enterElement\" class=\"container\">                                                           // 460\n             List of items:                                                                                            // 461\n             <div ng-repeat=\"item in [0, 1, 2, 3]\" class=\"item\">Item {{item}}</div>                                    // 462\n           </div>                                                                                                      // 463\n         </div>                                                                                                        // 464\n       </div>                                                                                                          // 465\n     </file>                                                                                                           // 466\n     <file name=\"animations.css\">                                                                                      // 467\n                                                                                                                       // 468\n      .container.ng-enter,                                                                                             // 469\n      .container.ng-leave {                                                                                            // 470\n        transition: all ease 1.5s;                                                                                     // 471\n      }                                                                                                                // 472\n                                                                                                                       // 473\n      .container.ng-enter,                                                                                             // 474\n      .container.ng-leave-active {                                                                                     // 475\n        opacity: 0;                                                                                                    // 476\n      }                                                                                                                // 477\n                                                                                                                       // 478\n      .container.ng-leave,                                                                                             // 479\n      .container.ng-enter-active {                                                                                     // 480\n        opacity: 1;                                                                                                    // 481\n      }                                                                                                                // 482\n                                                                                                                       // 483\n      .item {                                                                                                          // 484\n        background: firebrick;                                                                                         // 485\n        color: #FFF;                                                                                                   // 486\n        margin-bottom: 10px;                                                                                           // 487\n      }                                                                                                                // 488\n                                                                                                                       // 489\n      .item.ng-enter,                                                                                                  // 490\n      .item.ng-leave {                                                                                                 // 491\n        transition: transform 1.5s ease;                                                                               // 492\n      }                                                                                                                // 493\n                                                                                                                       // 494\n      .item.ng-enter {                                                                                                 // 495\n        transform: translateX(50px);                                                                                   // 496\n      }                                                                                                                // 497\n                                                                                                                       // 498\n      .item.ng-enter-active {                                                                                          // 499\n        transform: translateX(0);                                                                                      // 500\n      }                                                                                                                // 501\n    </file>                                                                                                            // 502\n    <file name=\"script.js\">                                                                                            // 503\n      angular.module('ngAnimateChildren', ['ngAnimate'])                                                               // 504\n        .controller('mainController', function() {                                                                     // 505\n          this.animateChildren = false;                                                                                // 506\n          this.enterElement = false;                                                                                   // 507\n        });                                                                                                            // 508\n    </file>                                                                                                            // 509\n  </example>                                                                                                           // 510\n */                                                                                                                    // 511\nvar $$AnimateChildrenDirective = ['$interpolate', function($interpolate) {                                             // 512\n  return {                                                                                                             // 513\n    link: function(scope, element, attrs) {                                                                            // 514\n      var val = attrs.ngAnimateChildren;                                                                               // 515\n      if (angular.isString(val) && val.length === 0) { //empty attribute                                               // 516\n        element.data(NG_ANIMATE_CHILDREN_DATA, true);                                                                  // 517\n      } else {                                                                                                         // 518\n        // Interpolate and set the value, so that it is available to                                                   // 519\n        // animations that run right after compilation                                                                 // 520\n        setData($interpolate(val)(scope));                                                                             // 521\n        attrs.$observe('ngAnimateChildren', setData);                                                                  // 522\n      }                                                                                                                // 523\n                                                                                                                       // 524\n      function setData(value) {                                                                                        // 525\n        value = value === 'on' || value === 'true';                                                                    // 526\n        element.data(NG_ANIMATE_CHILDREN_DATA, value);                                                                 // 527\n      }                                                                                                                // 528\n    }                                                                                                                  // 529\n  };                                                                                                                   // 530\n}];                                                                                                                    // 531\n                                                                                                                       // 532\nvar ANIMATE_TIMER_KEY = '$$animateCss';                                                                                // 533\n                                                                                                                       // 534\n/**                                                                                                                    // 535\n * @ngdoc service                                                                                                      // 536\n * @name $animateCss                                                                                                   // 537\n * @kind object                                                                                                        // 538\n *                                                                                                                     // 539\n * @description                                                                                                        // 540\n * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes                 // 541\n * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT                 // 542\n * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or                 // 543\n * directives to create more complex animations that can be purely driven using CSS code.                              // 544\n *                                                                                                                     // 545\n * Note that only browsers that support CSS transitions and/or keyframe animations are capable of                      // 546\n * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).                                      // 547\n *                                                                                                                     // 548\n * ## Usage                                                                                                            // 549\n * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that                   // 550\n * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,               // 551\n * any automatic control over cancelling animations and/or preventing animations from being run on                     // 552\n * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to               // 553\n * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger                   // 554\n * the CSS animation.                                                                                                  // 555\n *                                                                                                                     // 556\n * The example below shows how we can create a folding animation on an element using `ng-if`:                          // 557\n *                                                                                                                     // 558\n * ```html                                                                                                             // 559\n * <!-- notice the `fold-animation` CSS class -->                                                                      // 560\n * <div ng-if=\"onOff\" class=\"fold-animation\">                                                                          // 561\n *   This element will go BOOM                                                                                         // 562\n * </div>                                                                                                              // 563\n * <button ng-click=\"onOff=true\">Fold In</button>                                                                      // 564\n * ```                                                                                                                 // 565\n *                                                                                                                     // 566\n * Now we create the **JavaScript animation** that will trigger the CSS transition:                                    // 567\n *                                                                                                                     // 568\n * ```js                                                                                                               // 569\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {                                       // 570\n *   return {                                                                                                          // 571\n *     enter: function(element, doneFn) {                                                                              // 572\n *       var height = element[0].offsetHeight;                                                                         // 573\n *       return $animateCss(element, {                                                                                 // 574\n *         from: { height:'0px' },                                                                                     // 575\n *         to: { height:height + 'px' },                                                                               // 576\n *         duration: 1 // one second                                                                                   // 577\n *       });                                                                                                           // 578\n *     }                                                                                                               // 579\n *   }                                                                                                                 // 580\n * }]);                                                                                                                // 581\n * ```                                                                                                                 // 582\n *                                                                                                                     // 583\n * ## More Advanced Uses                                                                                               // 584\n *                                                                                                                     // 585\n * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks\n * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.\n *                                                                                                                     // 588\n * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,\n * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with\n * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order\n * to provide a working animation that will run in CSS.                                                                // 592\n *                                                                                                                     // 593\n * The example below showcases a more advanced version of the `.fold-animation` from the example above:                // 594\n *                                                                                                                     // 595\n * ```js                                                                                                               // 596\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {                                       // 597\n *   return {                                                                                                          // 598\n *     enter: function(element, doneFn) {                                                                              // 599\n *       var height = element[0].offsetHeight;                                                                         // 600\n *       return $animateCss(element, {                                                                                 // 601\n *         addClass: 'red large-text pulse-twice',                                                                     // 602\n *         easing: 'ease-out',                                                                                         // 603\n *         from: { height:'0px' },                                                                                     // 604\n *         to: { height:height + 'px' },                                                                               // 605\n *         duration: 1 // one second                                                                                   // 606\n *       });                                                                                                           // 607\n *     }                                                                                                               // 608\n *   }                                                                                                                 // 609\n * }]);                                                                                                                // 610\n * ```                                                                                                                 // 611\n *                                                                                                                     // 612\n * Since we're adding/removing CSS classes then the CSS transition will also pick those up:                            // 613\n *                                                                                                                     // 614\n * ```css                                                                                                              // 615\n * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,                         // 616\n * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/                 // 617\n * .red { background:red; }                                                                                            // 618\n * .large-text { font-size:20px; }                                                                                     // 619\n *                                                                                                                     // 620\n * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/       // 621\n * .pulse-twice {                                                                                                      // 622\n *   animation: 0.5s pulse linear 2;                                                                                   // 623\n *   -webkit-animation: 0.5s pulse linear 2;                                                                           // 624\n * }                                                                                                                   // 625\n *                                                                                                                     // 626\n * @keyframes pulse {                                                                                                  // 627\n *   from { transform: scale(0.5); }                                                                                   // 628\n *   to { transform: scale(1.5); }                                                                                     // 629\n * }                                                                                                                   // 630\n *                                                                                                                     // 631\n * @-webkit-keyframes pulse {                                                                                          // 632\n *   from { -webkit-transform: scale(0.5); }                                                                           // 633\n *   to { -webkit-transform: scale(1.5); }                                                                             // 634\n * }                                                                                                                   // 635\n * ```                                                                                                                 // 636\n *                                                                                                                     // 637\n * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.\n *                                                                                                                     // 639\n * ## How the Options are handled                                                                                      // 640\n *                                                                                                                     // 641\n * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation\n * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline\n * styles using the `from` and `to` properties.                                                                        // 644\n *                                                                                                                     // 645\n * ```js                                                                                                               // 646\n * var animator = $animateCss(element, {                                                                               // 647\n *   from: { background:'red' },                                                                                       // 648\n *   to: { background:'blue' }                                                                                         // 649\n * });                                                                                                                 // 650\n * animator.start();                                                                                                   // 651\n * ```                                                                                                                 // 652\n *                                                                                                                     // 653\n * ```css                                                                                                              // 654\n * .rotating-animation {                                                                                               // 655\n *   animation:0.5s rotate linear;                                                                                     // 656\n *   -webkit-animation:0.5s rotate linear;                                                                             // 657\n * }                                                                                                                   // 658\n *                                                                                                                     // 659\n * @keyframes rotate {                                                                                                 // 660\n *   from { transform: rotate(0deg); }                                                                                 // 661\n *   to { transform: rotate(360deg); }                                                                                 // 662\n * }                                                                                                                   // 663\n *                                                                                                                     // 664\n * @-webkit-keyframes rotate {                                                                                         // 665\n *   from { -webkit-transform: rotate(0deg); }                                                                         // 666\n *   to { -webkit-transform: rotate(360deg); }                                                                         // 667\n * }                                                                                                                   // 668\n * ```                                                                                                                 // 669\n *                                                                                                                     // 670\n * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is\n * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition\n * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition\n * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied\n * and spread across the transition and keyframe animation.                                                            // 675\n *                                                                                                                     // 676\n * ## What is returned                                                                                                 // 677\n *                                                                                                                     // 678\n * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually\n * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are\n * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:\n *                                                                                                                     // 682\n * ```js                                                                                                               // 683\n * var animator = $animateCss(element, { ... });                                                                       // 684\n * ```                                                                                                                 // 685\n *                                                                                                                     // 686\n * Now what do the contents of our `animator` variable look like:                                                      // 687\n *                                                                                                                     // 688\n * ```js                                                                                                               // 689\n * {                                                                                                                   // 690\n *   // starts the animation                                                                                           // 691\n *   start: Function,                                                                                                  // 692\n *                                                                                                                     // 693\n *   // ends (aborts) the animation                                                                                    // 694\n *   end: Function                                                                                                     // 695\n * }                                                                                                                   // 696\n * ```                                                                                                                 // 697\n *                                                                                                                     // 698\n * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.\n * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and styles may have been\n * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties\n * and that changing them will not reconfigure the parameters of the animation.                                        // 702\n *                                                                                                                     // 703\n * ### runner.done() vs runner.then()                                                                                  // 704\n * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the\n * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.\n * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`\n * unless you really need a digest to kick off afterwards.                                                             // 708\n *                                                                                                                     // 709\n * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss\n * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).                       // 711\n * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.                           // 712\n *                                                                                                                     // 713\n * @param {DOMElement} element the element that will be animated                                                       // 714\n * @param {object} options the animation-related options that will be applied during the animation                     // 715\n *                                                                                                                     // 716\n * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied\n * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)\n * * `structural` - Indicates that the `ng-` prefix will be added to the event class. Setting to `false` or omitting will turn `ng-EVENT` and\n * `ng-EVENT-active` in `EVENT` and `EVENT-active`. Unused if `event` is omitted.                                      // 720\n * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).           // 721\n * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).                        // 722\n * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).         // 723\n * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.         // 724\n * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.\n * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.\n * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.\n * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`\n * is provided then the animation will be skipped entirely.                                                            // 729\n * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is\n * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value\n * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same\n * CSS delay value.                                                                                                    // 733\n * * `stagger` - A numeric time value representing the delay between successively animated elements                    // 734\n * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})      // 735\n * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a\n *   `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)                            // 737\n * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occurring on the classes being added and removed.)\n * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once                         // 739\n *    the animation is closed. This is useful for when the styles are used purely for the sake of                      // 740\n *    the animation and do not have a lasting visual effect on the element (e.g. a collapse and open animation).       // 741\n *    By default this value is set to `false`.                                                                         // 742\n *                                                                                                                     // 743\n * @return {object} an object with start and end methods and details about the animation.                              // 744\n *                                                                                                                     // 745\n * * `start` - The method to start the animation. This will return a `Promise` when called.                            // 746\n * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.                      // 747\n */                                                                                                                    // 748\nvar ONE_SECOND = 1000;                                                                                                 // 749\nvar BASE_TEN = 10;                                                                                                     // 750\n                                                                                                                       // 751\nvar ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;                                                                               // 752\nvar CLOSING_TIME_BUFFER = 1.5;                                                                                         // 753\n                                                                                                                       // 754\nvar DETECT_CSS_PROPERTIES = {                                                                                          // 755\n  transitionDuration:      TRANSITION_DURATION_PROP,                                                                   // 756\n  transitionDelay:         TRANSITION_DELAY_PROP,                                                                      // 757\n  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,                                                             // 758\n  animationDuration:       ANIMATION_DURATION_PROP,                                                                    // 759\n  animationDelay:          ANIMATION_DELAY_PROP,                                                                       // 760\n  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY                                              // 761\n};                                                                                                                     // 762\n                                                                                                                       // 763\nvar DETECT_STAGGER_CSS_PROPERTIES = {                                                                                  // 764\n  transitionDuration:      TRANSITION_DURATION_PROP,                                                                   // 765\n  transitionDelay:         TRANSITION_DELAY_PROP,                                                                      // 766\n  animationDuration:       ANIMATION_DURATION_PROP,                                                                    // 767\n  animationDelay:          ANIMATION_DELAY_PROP                                                                        // 768\n};                                                                                                                     // 769\n                                                                                                                       // 770\nfunction getCssKeyframeDurationStyle(duration) {                                                                       // 771\n  return [ANIMATION_DURATION_PROP, duration + 's'];                                                                    // 772\n}                                                                                                                      // 773\n                                                                                                                       // 774\nfunction getCssDelayStyle(delay, isKeyframeAnimation) {                                                                // 775\n  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;                                       // 776\n  return [prop, delay + 's'];                                                                                          // 777\n}                                                                                                                      // 778\n                                                                                                                       // 779\nfunction computeCssStyles($window, element, properties) {                                                              // 780\n  var styles = Object.create(null);                                                                                    // 781\n  var detectedStyles = $window.getComputedStyle(element) || {};                                                        // 782\n  forEach(properties, function(formalStyleName, actualStyleName) {                                                     // 783\n    var val = detectedStyles[formalStyleName];                                                                         // 784\n    if (val) {                                                                                                         // 785\n      var c = val.charAt(0);                                                                                           // 786\n                                                                                                                       // 787\n      // only numerical-based values have a negative sign or digit as the first value                                  // 788\n      if (c === '-' || c === '+' || c >= 0) {                                                                          // 789\n        val = parseMaxTime(val);                                                                                       // 790\n      }                                                                                                                // 791\n                                                                                                                       // 792\n      // by setting this to null in the event that the delay is not set or is set directly as 0                        // 793\n      // then we can still allow for negative values to be used later on and not mistake this                          // 794\n      // value for being greater than any other negative value.                                                        // 795\n      if (val === 0) {                                                                                                 // 796\n        val = null;                                                                                                    // 797\n      }                                                                                                                // 798\n      styles[actualStyleName] = val;                                                                                   // 799\n    }                                                                                                                  // 800\n  });                                                                                                                  // 801\n                                                                                                                       // 802\n  return styles;                                                                                                       // 803\n}                                                                                                                      // 804\n                                                                                                                       // 805\nfunction parseMaxTime(str) {                                                                                           // 806\n  var maxValue = 0;                                                                                                    // 807\n  var values = str.split(/\\s*,\\s*/);                                                                                   // 808\n  forEach(values, function(value) {                                                                                    // 809\n    // it's always safe to consider only second values and omit `ms` values since                                      // 810\n    // getComputedStyle will always handle the conversion for us                                                       // 811\n    if (value.charAt(value.length - 1) == 's') {                                                                       // 812\n      value = value.substring(0, value.length - 1);                                                                    // 813\n    }                                                                                                                  // 814\n    value = parseFloat(value) || 0;                                                                                    // 815\n    maxValue = maxValue ? Math.max(value, maxValue) : value;                                                           // 816\n  });                                                                                                                  // 817\n  return maxValue;                                                                                                     // 818\n}                                                                                                                      // 819\n                                                                                                                       // 820\nfunction truthyTimingValue(val) {                                                                                      // 821\n  return val === 0 || val != null;                                                                                     // 822\n}                                                                                                                      // 823\n                                                                                                                       // 824\nfunction getCssTransitionDurationStyle(duration, applyOnlyDuration) {                                                  // 825\n  var style = TRANSITION_PROP;                                                                                         // 826\n  var value = duration + 's';                                                                                          // 827\n  if (applyOnlyDuration) {                                                                                             // 828\n    style += DURATION_KEY;                                                                                             // 829\n  } else {                                                                                                             // 830\n    value += ' linear all';                                                                                            // 831\n  }                                                                                                                    // 832\n  return [style, value];                                                                                               // 833\n}                                                                                                                      // 834\n                                                                                                                       // 835\nfunction createLocalCacheLookup() {                                                                                    // 836\n  var cache = Object.create(null);                                                                                     // 837\n  return {                                                                                                             // 838\n    flush: function() {                                                                                                // 839\n      cache = Object.create(null);                                                                                     // 840\n    },                                                                                                                 // 841\n                                                                                                                       // 842\n    count: function(key) {                                                                                             // 843\n      var entry = cache[key];                                                                                          // 844\n      return entry ? entry.total : 0;                                                                                  // 845\n    },                                                                                                                 // 846\n                                                                                                                       // 847\n    get: function(key) {                                                                                               // 848\n      var entry = cache[key];                                                                                          // 849\n      return entry && entry.value;                                                                                     // 850\n    },                                                                                                                 // 851\n                                                                                                                       // 852\n    put: function(key, value) {                                                                                        // 853\n      if (!cache[key]) {                                                                                               // 854\n        cache[key] = { total: 1, value: value };                                                                       // 855\n      } else {                                                                                                         // 856\n        cache[key].total++;                                                                                            // 857\n      }                                                                                                                // 858\n    }                                                                                                                  // 859\n  };                                                                                                                   // 860\n}                                                                                                                      // 861\n                                                                                                                       // 862\n// we do not reassign an already present style value since                                                             // 863\n// if we detect the style property value again we may be                                                               // 864\n// detecting styles that were added via the `from` styles.                                                             // 865\n// We make use of `isDefined` here since an empty string                                                               // 866\n// or null value (which is what getPropertyValue will return                                                           // 867\n// for a non-existing style) will still be marked as a valid                                                           // 868\n// value for the style (a falsy value implies that the style                                                           // 869\n// is to be removed at the end of the animation). If we had a simple                                                   // 870\n// \"OR\" statement then it would not be enough to catch that.                                                           // 871\nfunction registerRestorableStyles(backup, node, properties) {                                                          // 872\n  forEach(properties, function(prop) {                                                                                 // 873\n    backup[prop] = isDefined(backup[prop])                                                                             // 874\n        ? backup[prop]                                                                                                 // 875\n        : node.style.getPropertyValue(prop);                                                                           // 876\n  });                                                                                                                  // 877\n}                                                                                                                      // 878\n                                                                                                                       // 879\nvar $AnimateCssProvider = ['$animateProvider', function($animateProvider) {                                            // 880\n  var gcsLookup = createLocalCacheLookup();                                                                            // 881\n  var gcsStaggerLookup = createLocalCacheLookup();                                                                     // 882\n                                                                                                                       // 883\n  this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',                                                   // 884\n               '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue',                                        // 885\n       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,                                                    // 886\n                $$forceReflow,   $sniffer,   $$rAFScheduler, $$animateQueue) {                                         // 887\n                                                                                                                       // 888\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);                                                // 889\n                                                                                                                       // 890\n    var parentCounter = 0;                                                                                             // 891\n    function gcsHashFn(node, extraClasses) {                                                                           // 892\n      var KEY = \"$$ngAnimateParentKey\";                                                                                // 893\n      var parentNode = node.parentNode;                                                                                // 894\n      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);                                           // 895\n      return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;                                         // 896\n    }                                                                                                                  // 897\n                                                                                                                       // 898\n    function computeCachedCssStyles(node, className, cacheKey, properties) {                                           // 899\n      var timings = gcsLookup.get(cacheKey);                                                                           // 900\n                                                                                                                       // 901\n      if (!timings) {                                                                                                  // 902\n        timings = computeCssStyles($window, node, properties);                                                         // 903\n        if (timings.animationIterationCount === 'infinite') {                                                          // 904\n          timings.animationIterationCount = 1;                                                                         // 905\n        }                                                                                                              // 906\n      }                                                                                                                // 907\n                                                                                                                       // 908\n      // we keep putting this in multiple times even though the value and the cacheKey are the same                    // 909\n      // because we're keeping an internal tally of how many duplicate animations are detected.                        // 910\n      gcsLookup.put(cacheKey, timings);                                                                                // 911\n      return timings;                                                                                                  // 912\n    }                                                                                                                  // 913\n                                                                                                                       // 914\n    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {                                    // 915\n      var stagger;                                                                                                     // 916\n                                                                                                                       // 917\n      // if we have one or more existing matches of matching elements                                                  // 918\n      // containing the same parent + CSS styles (which is how cacheKey works)                                         // 919\n      // then staggering is possible                                                                                   // 920\n      if (gcsLookup.count(cacheKey) > 0) {                                                                             // 921\n        stagger = gcsStaggerLookup.get(cacheKey);                                                                      // 922\n                                                                                                                       // 923\n        if (!stagger) {                                                                                                // 924\n          var staggerClassName = pendClasses(className, '-stagger');                                                   // 925\n                                                                                                                       // 926\n          $$jqLite.addClass(node, staggerClassName);                                                                   // 927\n                                                                                                                       // 928\n          stagger = computeCssStyles($window, node, properties);                                                       // 929\n                                                                                                                       // 930\n          // force the conversion of a null value to zero incase not set                                               // 931\n          stagger.animationDuration = Math.max(stagger.animationDuration, 0);                                          // 932\n          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);                                        // 933\n                                                                                                                       // 934\n          $$jqLite.removeClass(node, staggerClassName);                                                                // 935\n                                                                                                                       // 936\n          gcsStaggerLookup.put(cacheKey, stagger);                                                                     // 937\n        }                                                                                                              // 938\n      }                                                                                                                // 939\n                                                                                                                       // 940\n      return stagger || {};                                                                                            // 941\n    }                                                                                                                  // 942\n                                                                                                                       // 943\n    var cancelLastRAFRequest;                                                                                          // 944\n    var rafWaitQueue = [];                                                                                             // 945\n    function waitUntilQuiet(callback) {                                                                                // 946\n      rafWaitQueue.push(callback);                                                                                     // 947\n      $$rAFScheduler.waitUntilQuiet(function() {                                                                       // 948\n        gcsLookup.flush();                                                                                             // 949\n        gcsStaggerLookup.flush();                                                                                      // 950\n                                                                                                                       // 951\n        // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.                                           // 952\n        // PLEASE EXAMINE THE `$$forceReflow` service to understand why.                                               // 953\n        var pageWidth = $$forceReflow();                                                                               // 954\n                                                                                                                       // 955\n        // we use a for loop to ensure that if the queue is changed                                                    // 956\n        // during this looping then it will consider new requests                                                      // 957\n        for (var i = 0; i < rafWaitQueue.length; i++) {                                                                // 958\n          rafWaitQueue[i](pageWidth);                                                                                  // 959\n        }                                                                                                              // 960\n        rafWaitQueue.length = 0;                                                                                       // 961\n      });                                                                                                              // 962\n    }                                                                                                                  // 963\n                                                                                                                       // 964\n    function computeTimings(node, className, cacheKey) {                                                               // 965\n      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);                          // 966\n      var aD = timings.animationDelay;                                                                                 // 967\n      var tD = timings.transitionDelay;                                                                                // 968\n      timings.maxDelay = aD && tD                                                                                      // 969\n          ? Math.max(aD, tD)                                                                                           // 970\n          : (aD || tD);                                                                                                // 971\n      timings.maxDuration = Math.max(                                                                                  // 972\n          timings.animationDuration * timings.animationIterationCount,                                                 // 973\n          timings.transitionDuration);                                                                                 // 974\n                                                                                                                       // 975\n      return timings;                                                                                                  // 976\n    }                                                                                                                  // 977\n                                                                                                                       // 978\n    return function init(element, initialOptions) {                                                                    // 979\n      // all of the animation functions should create                                                                  // 980\n      // a copy of the options data, however, if a                                                                     // 981\n      // parent service has already created a copy then                                                                // 982\n      // we should stick to using that                                                                                 // 983\n      var options = initialOptions || {};                                                                              // 984\n      if (!options.$$prepared) {                                                                                       // 985\n        options = prepareAnimationOptions(copy(options));                                                              // 986\n      }                                                                                                                // 987\n                                                                                                                       // 988\n      var restoreStyles = {};                                                                                          // 989\n      var node = getDomNode(element);                                                                                  // 990\n      if (!node                                                                                                        // 991\n          || !node.parentNode                                                                                          // 992\n          || !$$animateQueue.enabled()) {                                                                              // 993\n        return closeAndReturnNoopAnimator();                                                                           // 994\n      }                                                                                                                // 995\n                                                                                                                       // 996\n      var temporaryStyles = [];                                                                                        // 997\n      var classes = element.attr('class');                                                                             // 998\n      var styles = packageStyles(options);                                                                             // 999\n      var animationClosed;                                                                                             // 1000\n      var animationPaused;                                                                                             // 1001\n      var animationCompleted;                                                                                          // 1002\n      var runner;                                                                                                      // 1003\n      var runnerHost;                                                                                                  // 1004\n      var maxDelay;                                                                                                    // 1005\n      var maxDelayTime;                                                                                                // 1006\n      var maxDuration;                                                                                                 // 1007\n      var maxDurationTime;                                                                                             // 1008\n      var startTime;                                                                                                   // 1009\n      var events = [];                                                                                                 // 1010\n                                                                                                                       // 1011\n      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {                                 // 1012\n        return closeAndReturnNoopAnimator();                                                                           // 1013\n      }                                                                                                                // 1014\n                                                                                                                       // 1015\n      var method = options.event && isArray(options.event)                                                             // 1016\n            ? options.event.join(' ')                                                                                  // 1017\n            : options.event;                                                                                           // 1018\n                                                                                                                       // 1019\n      var isStructural = method && options.structural;                                                                 // 1020\n      var structuralClassName = '';                                                                                    // 1021\n      var addRemoveClassName = '';                                                                                     // 1022\n                                                                                                                       // 1023\n      if (isStructural) {                                                                                              // 1024\n        structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);                                           // 1025\n      } else if (method) {                                                                                             // 1026\n        structuralClassName = method;                                                                                  // 1027\n      }                                                                                                                // 1028\n                                                                                                                       // 1029\n      if (options.addClass) {                                                                                          // 1030\n        addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);                                         // 1031\n      }                                                                                                                // 1032\n                                                                                                                       // 1033\n      if (options.removeClass) {                                                                                       // 1034\n        if (addRemoveClassName.length) {                                                                               // 1035\n          addRemoveClassName += ' ';                                                                                   // 1036\n        }                                                                                                              // 1037\n        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);                                   // 1038\n      }                                                                                                                // 1039\n                                                                                                                       // 1040\n      // there may be a situation where a structural animation is combined together                                    // 1041\n      // with CSS classes that need to resolve before the animation is computed.                                       // 1042\n      // However this means that there is no explicit CSS code to block the animation                                  // 1043\n      // from happening (by setting 0s none in the class name). If this is the case                                    // 1044\n      // we need to apply the classes before the first rAF so we know to continue if                                   // 1045\n      // there actually is a detected transition or keyframe animation                                                 // 1046\n      if (options.applyClassesEarly && addRemoveClassName.length) {                                                    // 1047\n        applyAnimationClasses(element, options);                                                                       // 1048\n      }                                                                                                                // 1049\n                                                                                                                       // 1050\n      var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();                             // 1051\n      var fullClassName = classes + ' ' + preparationClasses;                                                          // 1052\n      var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);                                        // 1053\n      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;                                                // 1054\n      var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;                                        // 1055\n                                                                                                                       // 1056\n      // there is no way we can trigger an animation if no styles and                                                  // 1057\n      // no classes are being applied which would then trigger a transition,                                           // 1058\n      // unless there a is raw keyframe value that is applied to the element.                                          // 1059\n      if (!containsKeyframeAnimation                                                                                   // 1060\n           && !hasToStyles                                                                                             // 1061\n           && !preparationClasses) {                                                                                   // 1062\n        return closeAndReturnNoopAnimator();                                                                           // 1063\n      }                                                                                                                // 1064\n                                                                                                                       // 1065\n      var cacheKey, stagger;                                                                                           // 1066\n      if (options.stagger > 0) {                                                                                       // 1067\n        var staggerVal = parseFloat(options.stagger);                                                                  // 1068\n        stagger = {                                                                                                    // 1069\n          transitionDelay: staggerVal,                                                                                 // 1070\n          animationDelay: staggerVal,                                                                                  // 1071\n          transitionDuration: 0,                                                                                       // 1072\n          animationDuration: 0                                                                                         // 1073\n        };                                                                                                             // 1074\n      } else {                                                                                                         // 1075\n        cacheKey = gcsHashFn(node, fullClassName);                                                                     // 1076\n        stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);    // 1077\n      }                                                                                                                // 1078\n                                                                                                                       // 1079\n      if (!options.$$skipPreparationClasses) {                                                                         // 1080\n        $$jqLite.addClass(element, preparationClasses);                                                                // 1081\n      }                                                                                                                // 1082\n                                                                                                                       // 1083\n      var applyOnlyDuration;                                                                                           // 1084\n                                                                                                                       // 1085\n      if (options.transitionStyle) {                                                                                   // 1086\n        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];                                              // 1087\n        applyInlineStyle(node, transitionStyle);                                                                       // 1088\n        temporaryStyles.push(transitionStyle);                                                                         // 1089\n      }                                                                                                                // 1090\n                                                                                                                       // 1091\n      if (options.duration >= 0) {                                                                                     // 1092\n        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;                                                    // 1093\n        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);                        // 1094\n                                                                                                                       // 1095\n        // we set the duration so that it will be picked up by getComputedStyle later                                  // 1096\n        applyInlineStyle(node, durationStyle);                                                                         // 1097\n        temporaryStyles.push(durationStyle);                                                                           // 1098\n      }                                                                                                                // 1099\n                                                                                                                       // 1100\n      if (options.keyframeStyle) {                                                                                     // 1101\n        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];                                                   // 1102\n        applyInlineStyle(node, keyframeStyle);                                                                         // 1103\n        temporaryStyles.push(keyframeStyle);                                                                           // 1104\n      }                                                                                                                // 1105\n                                                                                                                       // 1106\n      var itemIndex = stagger                                                                                          // 1107\n          ? options.staggerIndex >= 0                                                                                  // 1108\n              ? options.staggerIndex                                                                                   // 1109\n              : gcsLookup.count(cacheKey)                                                                              // 1110\n          : 0;                                                                                                         // 1111\n                                                                                                                       // 1112\n      var isFirst = itemIndex === 0;                                                                                   // 1113\n                                                                                                                       // 1114\n      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY                      // 1115\n      // without causing any combination of transitions to kick in. By adding a negative delay value                   // 1116\n      // it forces the setup class' transition to end immediately. We later then remove the negative                   // 1117\n      // transition delay to allow for the transition to naturally do it's thing. The beauty here is                   // 1118\n      // that if there is no transition defined then nothing will happen and this will also allow                      // 1119\n      // other transitions to be stacked on top of each other without any chopping them out.                           // 1120\n      if (isFirst && !options.skipBlocking) {                                                                          // 1121\n        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);                                                      // 1122\n      }                                                                                                                // 1123\n                                                                                                                       // 1124\n      var timings = computeTimings(node, fullClassName, cacheKey);                                                     // 1125\n      var relativeDelay = timings.maxDelay;                                                                            // 1126\n      maxDelay = Math.max(relativeDelay, 0);                                                                           // 1127\n      maxDuration = timings.maxDuration;                                                                               // 1128\n                                                                                                                       // 1129\n      var flags = {};                                                                                                  // 1130\n      flags.hasTransitions          = timings.transitionDuration > 0;                                                  // 1131\n      flags.hasAnimations           = timings.animationDuration > 0;                                                   // 1132\n      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty == 'all';                     // 1133\n      flags.applyTransitionDuration = hasToStyles && (                                                                 // 1134\n                                        (flags.hasTransitions && !flags.hasTransitionAll)                              // 1135\n                                         || (flags.hasAnimations && !flags.hasTransitions));                           // 1136\n      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;                                         // 1137\n      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);\n      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;                         // 1139\n      flags.recalculateTimingStyles = addRemoveClassName.length > 0;                                                   // 1140\n                                                                                                                       // 1141\n      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {                                             // 1142\n        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;                                   // 1143\n                                                                                                                       // 1144\n        if (flags.applyTransitionDuration) {                                                                           // 1145\n          flags.hasTransitions = true;                                                                                 // 1146\n          timings.transitionDuration = maxDuration;                                                                    // 1147\n          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;                                   // 1148\n          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));                         // 1149\n        }                                                                                                              // 1150\n                                                                                                                       // 1151\n        if (flags.applyAnimationDuration) {                                                                            // 1152\n          flags.hasAnimations = true;                                                                                  // 1153\n          timings.animationDuration = maxDuration;                                                                     // 1154\n          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));                                              // 1155\n        }                                                                                                              // 1156\n      }                                                                                                                // 1157\n                                                                                                                       // 1158\n      if (maxDuration === 0 && !flags.recalculateTimingStyles) {                                                       // 1159\n        return closeAndReturnNoopAnimator();                                                                           // 1160\n      }                                                                                                                // 1161\n                                                                                                                       // 1162\n      if (options.delay != null) {                                                                                     // 1163\n        var delayStyle;                                                                                                // 1164\n        if (typeof options.delay !== \"boolean\") {                                                                      // 1165\n          delayStyle = parseFloat(options.delay);                                                                      // 1166\n          // number in options.delay means we have to recalculate the delay for the closing timeout                    // 1167\n          maxDelay = Math.max(delayStyle, 0);                                                                          // 1168\n        }                                                                                                              // 1169\n                                                                                                                       // 1170\n        if (flags.applyTransitionDelay) {                                                                              // 1171\n          temporaryStyles.push(getCssDelayStyle(delayStyle));                                                          // 1172\n        }                                                                                                              // 1173\n                                                                                                                       // 1174\n        if (flags.applyAnimationDelay) {                                                                               // 1175\n          temporaryStyles.push(getCssDelayStyle(delayStyle, true));                                                    // 1176\n        }                                                                                                              // 1177\n      }                                                                                                                // 1178\n                                                                                                                       // 1179\n      // we need to recalculate the delay value since we used a pre-emptive negative                                   // 1180\n      // delay value and the delay value is required for the final event checking. This                                // 1181\n      // property will ensure that this will happen after the RAF phase has passed.                                    // 1182\n      if (options.duration == null && timings.transitionDuration > 0) {                                                // 1183\n        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;                                      // 1184\n      }                                                                                                                // 1185\n                                                                                                                       // 1186\n      maxDelayTime = maxDelay * ONE_SECOND;                                                                            // 1187\n      maxDurationTime = maxDuration * ONE_SECOND;                                                                      // 1188\n      if (!options.skipBlocking) {                                                                                     // 1189\n        flags.blockTransition = timings.transitionDuration > 0;                                                        // 1190\n        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&                                                // 1191\n                                       stagger.animationDelay > 0 &&                                                   // 1192\n                                       stagger.animationDuration === 0;                                                // 1193\n      }                                                                                                                // 1194\n                                                                                                                       // 1195\n      if (options.from) {                                                                                              // 1196\n        if (options.cleanupStyles) {                                                                                   // 1197\n          registerRestorableStyles(restoreStyles, node, Object.keys(options.from));                                    // 1198\n        }                                                                                                              // 1199\n        applyAnimationFromStyles(element, options);                                                                    // 1200\n      }                                                                                                                // 1201\n                                                                                                                       // 1202\n      if (flags.blockTransition || flags.blockKeyframeAnimation) {                                                     // 1203\n        applyBlocking(maxDuration);                                                                                    // 1204\n      } else if (!options.skipBlocking) {                                                                              // 1205\n        blockTransitions(node, false);                                                                                 // 1206\n      }                                                                                                                // 1207\n                                                                                                                       // 1208\n      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging                        // 1209\n      return {                                                                                                         // 1210\n        $$willAnimate: true,                                                                                           // 1211\n        end: endFn,                                                                                                    // 1212\n        start: function() {                                                                                            // 1213\n          if (animationClosed) return;                                                                                 // 1214\n                                                                                                                       // 1215\n          runnerHost = {                                                                                               // 1216\n            end: endFn,                                                                                                // 1217\n            cancel: cancelFn,                                                                                          // 1218\n            resume: null, //this will be set during the start() phase                                                  // 1219\n            pause: null                                                                                                // 1220\n          };                                                                                                           // 1221\n                                                                                                                       // 1222\n          runner = new $$AnimateRunner(runnerHost);                                                                    // 1223\n                                                                                                                       // 1224\n          waitUntilQuiet(start);                                                                                       // 1225\n                                                                                                                       // 1226\n          // we don't have access to pause/resume the animation                                                        // 1227\n          // since it hasn't run yet. AnimateRunner will therefore                                                     // 1228\n          // set noop functions for resume and pause and they will                                                     // 1229\n          // later be overridden once the animation is triggered                                                       // 1230\n          return runner;                                                                                               // 1231\n        }                                                                                                              // 1232\n      };                                                                                                               // 1233\n                                                                                                                       // 1234\n      function endFn() {                                                                                               // 1235\n        close();                                                                                                       // 1236\n      }                                                                                                                // 1237\n                                                                                                                       // 1238\n      function cancelFn() {                                                                                            // 1239\n        close(true);                                                                                                   // 1240\n      }                                                                                                                // 1241\n                                                                                                                       // 1242\n      function close(rejected) { // jshint ignore:line                                                                 // 1243\n        // if the promise has been called already then we shouldn't close                                              // 1244\n        // the animation again                                                                                         // 1245\n        if (animationClosed || (animationCompleted && animationPaused)) return;                                        // 1246\n        animationClosed = true;                                                                                        // 1247\n        animationPaused = false;                                                                                       // 1248\n                                                                                                                       // 1249\n        if (!options.$$skipPreparationClasses) {                                                                       // 1250\n          $$jqLite.removeClass(element, preparationClasses);                                                           // 1251\n        }                                                                                                              // 1252\n        $$jqLite.removeClass(element, activeClasses);                                                                  // 1253\n                                                                                                                       // 1254\n        blockKeyframeAnimations(node, false);                                                                          // 1255\n        blockTransitions(node, false);                                                                                 // 1256\n                                                                                                                       // 1257\n        forEach(temporaryStyles, function(entry) {                                                                     // 1258\n          // There is only one way to remove inline style properties entirely from elements.                           // 1259\n          // By using `removeProperty` this works, but we need to convert camel-cased CSS                              // 1260\n          // styles down to hyphenated values.                                                                         // 1261\n          node.style[entry[0]] = '';                                                                                   // 1262\n        });                                                                                                            // 1263\n                                                                                                                       // 1264\n        applyAnimationClasses(element, options);                                                                       // 1265\n        applyAnimationStyles(element, options);                                                                        // 1266\n                                                                                                                       // 1267\n        if (Object.keys(restoreStyles).length) {                                                                       // 1268\n          forEach(restoreStyles, function(value, prop) {                                                               // 1269\n            value ? node.style.setProperty(prop, value)                                                                // 1270\n                  : node.style.removeProperty(prop);                                                                   // 1271\n          });                                                                                                          // 1272\n        }                                                                                                              // 1273\n                                                                                                                       // 1274\n        // the reason why we have this option is to allow a synchronous closing callback                               // 1275\n        // that is fired as SOON as the animation ends (when the CSS is removed) or if                                 // 1276\n        // the animation never takes off at all. A good example is a leave animation since                             // 1277\n        // the element must be removed just after the animation is over or else the element                            // 1278\n        // will appear on screen for one animation frame causing an overbearing flicker.                               // 1279\n        if (options.onDone) {                                                                                          // 1280\n          options.onDone();                                                                                            // 1281\n        }                                                                                                              // 1282\n                                                                                                                       // 1283\n        if (events && events.length) {                                                                                 // 1284\n          // Remove the transitionend / animationend listener(s)                                                       // 1285\n          element.off(events.join(' '), onAnimationProgress);                                                          // 1286\n        }                                                                                                              // 1287\n                                                                                                                       // 1288\n        //Cancel the fallback closing timeout and remove the timer data                                                // 1289\n        var animationTimerData = element.data(ANIMATE_TIMER_KEY);                                                      // 1290\n        if (animationTimerData) {                                                                                      // 1291\n          $timeout.cancel(animationTimerData[0].timer);                                                                // 1292\n          element.removeData(ANIMATE_TIMER_KEY);                                                                       // 1293\n        }                                                                                                              // 1294\n                                                                                                                       // 1295\n        // if the preparation function fails then the promise is not setup                                             // 1296\n        if (runner) {                                                                                                  // 1297\n          runner.complete(!rejected);                                                                                  // 1298\n        }                                                                                                              // 1299\n      }                                                                                                                // 1300\n                                                                                                                       // 1301\n      function applyBlocking(duration) {                                                                               // 1302\n        if (flags.blockTransition) {                                                                                   // 1303\n          blockTransitions(node, duration);                                                                            // 1304\n        }                                                                                                              // 1305\n                                                                                                                       // 1306\n        if (flags.blockKeyframeAnimation) {                                                                            // 1307\n          blockKeyframeAnimations(node, !!duration);                                                                   // 1308\n        }                                                                                                              // 1309\n      }                                                                                                                // 1310\n                                                                                                                       // 1311\n      function closeAndReturnNoopAnimator() {                                                                          // 1312\n        runner = new $$AnimateRunner({                                                                                 // 1313\n          end: endFn,                                                                                                  // 1314\n          cancel: cancelFn                                                                                             // 1315\n        });                                                                                                            // 1316\n                                                                                                                       // 1317\n        // should flush the cache animation                                                                            // 1318\n        waitUntilQuiet(noop);                                                                                          // 1319\n        close();                                                                                                       // 1320\n                                                                                                                       // 1321\n        return {                                                                                                       // 1322\n          $$willAnimate: false,                                                                                        // 1323\n          start: function() {                                                                                          // 1324\n            return runner;                                                                                             // 1325\n          },                                                                                                           // 1326\n          end: endFn                                                                                                   // 1327\n        };                                                                                                             // 1328\n      }                                                                                                                // 1329\n                                                                                                                       // 1330\n      function onAnimationProgress(event) {                                                                            // 1331\n        event.stopPropagation();                                                                                       // 1332\n        var ev = event.originalEvent || event;                                                                         // 1333\n                                                                                                                       // 1334\n        // we now always use `Date.now()` due to the recent changes with                                               // 1335\n        // event.timeStamp in Firefox, Webkit and Chrome (see #13494 for more info)                                    // 1336\n        var timeStamp = ev.$manualTimeStamp || Date.now();                                                             // 1337\n                                                                                                                       // 1338\n        /* Firefox (or possibly just Gecko) likes to not round values up                                               // 1339\n         * when a ms measurement is used for the animation */                                                          // 1340\n        var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));                         // 1341\n                                                                                                                       // 1342\n        /* $manualTimeStamp is a mocked timeStamp value which is set                                                   // 1343\n         * within browserTrigger(). This is only here so that tests can                                                // 1344\n         * mock animations properly. Real events fallback to event.timeStamp,                                          // 1345\n         * or, if they don't, then a timeStamp is automatically created for them.                                      // 1346\n         * We're checking to see if the timeStamp surpasses the expected delay,                                        // 1347\n         * but we're using elapsedTime instead of the timeStamp on the 2nd                                             // 1348\n         * pre-condition since animationPauseds sometimes close off early */                                           // 1349\n        if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {                        // 1350\n          // we set this flag to ensure that if the transition is paused then, when resumed,                           // 1351\n          // the animation will automatically close itself since transitions cannot be paused.                         // 1352\n          animationCompleted = true;                                                                                   // 1353\n          close();                                                                                                     // 1354\n        }                                                                                                              // 1355\n      }                                                                                                                // 1356\n                                                                                                                       // 1357\n      function start() {                                                                                               // 1358\n        if (animationClosed) return;                                                                                   // 1359\n        if (!node.parentNode) {                                                                                        // 1360\n          close();                                                                                                     // 1361\n          return;                                                                                                      // 1362\n        }                                                                                                              // 1363\n                                                                                                                       // 1364\n        // even though we only pause keyframe animations here the pause flag                                           // 1365\n        // will still happen when transitions are used. Only the transition will                                       // 1366\n        // not be paused since that is not possible. If the animation ends when                                        // 1367\n        // paused then it will not complete until unpaused or cancelled.                                               // 1368\n        var playPause = function(playAnimation) {                                                                      // 1369\n          if (!animationCompleted) {                                                                                   // 1370\n            animationPaused = !playAnimation;                                                                          // 1371\n            if (timings.animationDuration) {                                                                           // 1372\n              var value = blockKeyframeAnimations(node, animationPaused);                                              // 1373\n              animationPaused                                                                                          // 1374\n                  ? temporaryStyles.push(value)                                                                        // 1375\n                  : removeFromArray(temporaryStyles, value);                                                           // 1376\n            }                                                                                                          // 1377\n          } else if (animationPaused && playAnimation) {                                                               // 1378\n            animationPaused = false;                                                                                   // 1379\n            close();                                                                                                   // 1380\n          }                                                                                                            // 1381\n        };                                                                                                             // 1382\n                                                                                                                       // 1383\n        // checking the stagger duration prevents an accidentally cascade of the CSS delay style                       // 1384\n        // being inherited from the parent. If the transition duration is zero then we can safely                      // 1385\n        // rely that the delay value is an intentional stagger delay style.                                            // 1386\n        var maxStagger = itemIndex > 0                                                                                 // 1387\n                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||                       // 1388\n                            (timings.animationDuration && stagger.animationDuration === 0))                            // 1389\n                         && Math.max(stagger.animationDelay, stagger.transitionDelay);                                 // 1390\n        if (maxStagger) {                                                                                              // 1391\n          $timeout(triggerAnimationStart,                                                                              // 1392\n                   Math.floor(maxStagger * itemIndex * ONE_SECOND),                                                    // 1393\n                   false);                                                                                             // 1394\n        } else {                                                                                                       // 1395\n          triggerAnimationStart();                                                                                     // 1396\n        }                                                                                                              // 1397\n                                                                                                                       // 1398\n        // this will decorate the existing promise runner with pause/resume methods                                    // 1399\n        runnerHost.resume = function() {                                                                               // 1400\n          playPause(true);                                                                                             // 1401\n        };                                                                                                             // 1402\n                                                                                                                       // 1403\n        runnerHost.pause = function() {                                                                                // 1404\n          playPause(false);                                                                                            // 1405\n        };                                                                                                             // 1406\n                                                                                                                       // 1407\n        function triggerAnimationStart() {                                                                             // 1408\n          // just incase a stagger animation kicks in when the animation                                               // 1409\n          // itself was cancelled entirely                                                                             // 1410\n          if (animationClosed) return;                                                                                 // 1411\n                                                                                                                       // 1412\n          applyBlocking(false);                                                                                        // 1413\n                                                                                                                       // 1414\n          forEach(temporaryStyles, function(entry) {                                                                   // 1415\n            var key = entry[0];                                                                                        // 1416\n            var value = entry[1];                                                                                      // 1417\n            node.style[key] = value;                                                                                   // 1418\n          });                                                                                                          // 1419\n                                                                                                                       // 1420\n          applyAnimationClasses(element, options);                                                                     // 1421\n          $$jqLite.addClass(element, activeClasses);                                                                   // 1422\n                                                                                                                       // 1423\n          if (flags.recalculateTimingStyles) {                                                                         // 1424\n            fullClassName = node.className + ' ' + preparationClasses;                                                 // 1425\n            cacheKey = gcsHashFn(node, fullClassName);                                                                 // 1426\n                                                                                                                       // 1427\n            timings = computeTimings(node, fullClassName, cacheKey);                                                   // 1428\n            relativeDelay = timings.maxDelay;                                                                          // 1429\n            maxDelay = Math.max(relativeDelay, 0);                                                                     // 1430\n            maxDuration = timings.maxDuration;                                                                         // 1431\n                                                                                                                       // 1432\n            if (maxDuration === 0) {                                                                                   // 1433\n              close();                                                                                                 // 1434\n              return;                                                                                                  // 1435\n            }                                                                                                          // 1436\n                                                                                                                       // 1437\n            flags.hasTransitions = timings.transitionDuration > 0;                                                     // 1438\n            flags.hasAnimations = timings.animationDuration > 0;                                                       // 1439\n          }                                                                                                            // 1440\n                                                                                                                       // 1441\n          if (flags.applyAnimationDelay) {                                                                             // 1442\n            relativeDelay = typeof options.delay !== \"boolean\" && truthyTimingValue(options.delay)                     // 1443\n                  ? parseFloat(options.delay)                                                                          // 1444\n                  : relativeDelay;                                                                                     // 1445\n                                                                                                                       // 1446\n            maxDelay = Math.max(relativeDelay, 0);                                                                     // 1447\n            timings.animationDelay = relativeDelay;                                                                    // 1448\n            delayStyle = getCssDelayStyle(relativeDelay, true);                                                        // 1449\n            temporaryStyles.push(delayStyle);                                                                          // 1450\n            node.style[delayStyle[0]] = delayStyle[1];                                                                 // 1451\n          }                                                                                                            // 1452\n                                                                                                                       // 1453\n          maxDelayTime = maxDelay * ONE_SECOND;                                                                        // 1454\n          maxDurationTime = maxDuration * ONE_SECOND;                                                                  // 1455\n                                                                                                                       // 1456\n          if (options.easing) {                                                                                        // 1457\n            var easeProp, easeVal = options.easing;                                                                    // 1458\n            if (flags.hasTransitions) {                                                                                // 1459\n              easeProp = TRANSITION_PROP + TIMING_KEY;                                                                 // 1460\n              temporaryStyles.push([easeProp, easeVal]);                                                               // 1461\n              node.style[easeProp] = easeVal;                                                                          // 1462\n            }                                                                                                          // 1463\n            if (flags.hasAnimations) {                                                                                 // 1464\n              easeProp = ANIMATION_PROP + TIMING_KEY;                                                                  // 1465\n              temporaryStyles.push([easeProp, easeVal]);                                                               // 1466\n              node.style[easeProp] = easeVal;                                                                          // 1467\n            }                                                                                                          // 1468\n          }                                                                                                            // 1469\n                                                                                                                       // 1470\n          if (timings.transitionDuration) {                                                                            // 1471\n            events.push(TRANSITIONEND_EVENT);                                                                          // 1472\n          }                                                                                                            // 1473\n                                                                                                                       // 1474\n          if (timings.animationDuration) {                                                                             // 1475\n            events.push(ANIMATIONEND_EVENT);                                                                           // 1476\n          }                                                                                                            // 1477\n                                                                                                                       // 1478\n          startTime = Date.now();                                                                                      // 1479\n          var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;                                        // 1480\n          var endTime = startTime + timerTime;                                                                         // 1481\n                                                                                                                       // 1482\n          var animationsData = element.data(ANIMATE_TIMER_KEY) || [];                                                  // 1483\n          var setupFallbackTimer = true;                                                                               // 1484\n          if (animationsData.length) {                                                                                 // 1485\n            var currentTimerData = animationsData[0];                                                                  // 1486\n            setupFallbackTimer = endTime > currentTimerData.expectedEndTime;                                           // 1487\n            if (setupFallbackTimer) {                                                                                  // 1488\n              $timeout.cancel(currentTimerData.timer);                                                                 // 1489\n            } else {                                                                                                   // 1490\n              animationsData.push(close);                                                                              // 1491\n            }                                                                                                          // 1492\n          }                                                                                                            // 1493\n                                                                                                                       // 1494\n          if (setupFallbackTimer) {                                                                                    // 1495\n            var timer = $timeout(onAnimationExpired, timerTime, false);                                                // 1496\n            animationsData[0] = {                                                                                      // 1497\n              timer: timer,                                                                                            // 1498\n              expectedEndTime: endTime                                                                                 // 1499\n            };                                                                                                         // 1500\n            animationsData.push(close);                                                                                // 1501\n            element.data(ANIMATE_TIMER_KEY, animationsData);                                                           // 1502\n          }                                                                                                            // 1503\n                                                                                                                       // 1504\n          if (events.length) {                                                                                         // 1505\n            element.on(events.join(' '), onAnimationProgress);                                                         // 1506\n          }                                                                                                            // 1507\n                                                                                                                       // 1508\n          if (options.to) {                                                                                            // 1509\n            if (options.cleanupStyles) {                                                                               // 1510\n              registerRestorableStyles(restoreStyles, node, Object.keys(options.to));                                  // 1511\n            }                                                                                                          // 1512\n            applyAnimationToStyles(element, options);                                                                  // 1513\n          }                                                                                                            // 1514\n        }                                                                                                              // 1515\n                                                                                                                       // 1516\n        function onAnimationExpired() {                                                                                // 1517\n          var animationsData = element.data(ANIMATE_TIMER_KEY);                                                        // 1518\n                                                                                                                       // 1519\n          // this will be false in the event that the element was                                                      // 1520\n          // removed from the DOM (via a leave animation or something                                                  // 1521\n          // similar)                                                                                                  // 1522\n          if (animationsData) {                                                                                        // 1523\n            for (var i = 1; i < animationsData.length; i++) {                                                          // 1524\n              animationsData[i]();                                                                                     // 1525\n            }                                                                                                          // 1526\n            element.removeData(ANIMATE_TIMER_KEY);                                                                     // 1527\n          }                                                                                                            // 1528\n        }                                                                                                              // 1529\n      }                                                                                                                // 1530\n    };                                                                                                                 // 1531\n  }];                                                                                                                  // 1532\n}];                                                                                                                    // 1533\n                                                                                                                       // 1534\nvar $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {                               // 1535\n  $$animationProvider.drivers.push('$$animateCssDriver');                                                              // 1536\n                                                                                                                       // 1537\n  var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';                                                                  // 1538\n  var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';                                                                      // 1539\n                                                                                                                       // 1540\n  var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';                                                                      // 1541\n  var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';                                                                        // 1542\n                                                                                                                       // 1543\n  function isDocumentFragment(node) {                                                                                  // 1544\n    return node.parentNode && node.parentNode.nodeType === 11;                                                         // 1545\n  }                                                                                                                    // 1546\n                                                                                                                       // 1547\n  this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',    // 1548\n       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $sniffer,   $$jqLite,   $document) {   // 1549\n                                                                                                                       // 1550\n    // only browsers that support these properties can render animations                                               // 1551\n    if (!$sniffer.animations && !$sniffer.transitions) return noop;                                                    // 1552\n                                                                                                                       // 1553\n    var bodyNode = $document[0].body;                                                                                  // 1554\n    var rootNode = getDomNode($rootElement);                                                                           // 1555\n                                                                                                                       // 1556\n    var rootBodyElement = jqLite(                                                                                      // 1557\n      // this is to avoid using something that exists outside of the body                                              // 1558\n      // we also special case the doc fragment case because our unit test code                                         // 1559\n      // appends the $rootElement to the body after the app has been bootstrapped                                      // 1560\n      isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode                                // 1561\n    );                                                                                                                 // 1562\n                                                                                                                       // 1563\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);                                                // 1564\n                                                                                                                       // 1565\n    return function initDriverFn(animationDetails) {                                                                   // 1566\n      return animationDetails.from && animationDetails.to                                                              // 1567\n          ? prepareFromToAnchorAnimation(animationDetails.from,                                                        // 1568\n                                         animationDetails.to,                                                          // 1569\n                                         animationDetails.classes,                                                     // 1570\n                                         animationDetails.anchors)                                                     // 1571\n          : prepareRegularAnimation(animationDetails);                                                                 // 1572\n    };                                                                                                                 // 1573\n                                                                                                                       // 1574\n    function filterCssClasses(classes) {                                                                               // 1575\n      //remove all the `ng-` stuff                                                                                     // 1576\n      return classes.replace(/\\bng-\\S+\\b/g, '');                                                                       // 1577\n    }                                                                                                                  // 1578\n                                                                                                                       // 1579\n    function getUniqueValues(a, b) {                                                                                   // 1580\n      if (isString(a)) a = a.split(' ');                                                                               // 1581\n      if (isString(b)) b = b.split(' ');                                                                               // 1582\n      return a.filter(function(val) {                                                                                  // 1583\n        return b.indexOf(val) === -1;                                                                                  // 1584\n      }).join(' ');                                                                                                    // 1585\n    }                                                                                                                  // 1586\n                                                                                                                       // 1587\n    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {                                                  // 1588\n      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));                                                       // 1589\n      var startingClasses = filterCssClasses(getClassVal(clone));                                                      // 1590\n                                                                                                                       // 1591\n      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);                                                                  // 1592\n      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);                                                                   // 1593\n                                                                                                                       // 1594\n      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);                                                                    // 1595\n                                                                                                                       // 1596\n      rootBodyElement.append(clone);                                                                                   // 1597\n                                                                                                                       // 1598\n      var animatorIn, animatorOut = prepareOutAnimation();                                                             // 1599\n                                                                                                                       // 1600\n      // the user may not end up using the `out` animation and                                                         // 1601\n      // only making use of the `in` animation or vice-versa.                                                          // 1602\n      // In either case we should allow this and not assume the                                                        // 1603\n      // animation is over unless both animations are not used.                                                        // 1604\n      if (!animatorOut) {                                                                                              // 1605\n        animatorIn = prepareInAnimation();                                                                             // 1606\n        if (!animatorIn) {                                                                                             // 1607\n          return end();                                                                                                // 1608\n        }                                                                                                              // 1609\n      }                                                                                                                // 1610\n                                                                                                                       // 1611\n      var startingAnimator = animatorOut || animatorIn;                                                                // 1612\n                                                                                                                       // 1613\n      return {                                                                                                         // 1614\n        start: function() {                                                                                            // 1615\n          var runner;                                                                                                  // 1616\n                                                                                                                       // 1617\n          var currentAnimation = startingAnimator.start();                                                             // 1618\n          currentAnimation.done(function() {                                                                           // 1619\n            currentAnimation = null;                                                                                   // 1620\n            if (!animatorIn) {                                                                                         // 1621\n              animatorIn = prepareInAnimation();                                                                       // 1622\n              if (animatorIn) {                                                                                        // 1623\n                currentAnimation = animatorIn.start();                                                                 // 1624\n                currentAnimation.done(function() {                                                                     // 1625\n                  currentAnimation = null;                                                                             // 1626\n                  end();                                                                                               // 1627\n                  runner.complete();                                                                                   // 1628\n                });                                                                                                    // 1629\n                return currentAnimation;                                                                               // 1630\n              }                                                                                                        // 1631\n            }                                                                                                          // 1632\n            // in the event that there is no `in` animation                                                            // 1633\n            end();                                                                                                     // 1634\n            runner.complete();                                                                                         // 1635\n          });                                                                                                          // 1636\n                                                                                                                       // 1637\n          runner = new $$AnimateRunner({                                                                               // 1638\n            end: endFn,                                                                                                // 1639\n            cancel: endFn                                                                                              // 1640\n          });                                                                                                          // 1641\n                                                                                                                       // 1642\n          return runner;                                                                                               // 1643\n                                                                                                                       // 1644\n          function endFn() {                                                                                           // 1645\n            if (currentAnimation) {                                                                                    // 1646\n              currentAnimation.end();                                                                                  // 1647\n            }                                                                                                          // 1648\n          }                                                                                                            // 1649\n        }                                                                                                              // 1650\n      };                                                                                                               // 1651\n                                                                                                                       // 1652\n      function calculateAnchorStyles(anchor) {                                                                         // 1653\n        var styles = {};                                                                                               // 1654\n                                                                                                                       // 1655\n        var coords = getDomNode(anchor).getBoundingClientRect();                                                       // 1656\n                                                                                                                       // 1657\n        // we iterate directly since safari messes up and doesn't return                                               // 1658\n        // all the keys for the coords object when iterated                                                            // 1659\n        forEach(['width','height','top','left'], function(key) {                                                       // 1660\n          var value = coords[key];                                                                                     // 1661\n          switch (key) {                                                                                               // 1662\n            case 'top':                                                                                                // 1663\n              value += bodyNode.scrollTop;                                                                             // 1664\n              break;                                                                                                   // 1665\n            case 'left':                                                                                               // 1666\n              value += bodyNode.scrollLeft;                                                                            // 1667\n              break;                                                                                                   // 1668\n          }                                                                                                            // 1669\n          styles[key] = Math.floor(value) + 'px';                                                                      // 1670\n        });                                                                                                            // 1671\n        return styles;                                                                                                 // 1672\n      }                                                                                                                // 1673\n                                                                                                                       // 1674\n      function prepareOutAnimation() {                                                                                 // 1675\n        var animator = $animateCss(clone, {                                                                            // 1676\n          addClass: NG_OUT_ANCHOR_CLASS_NAME,                                                                          // 1677\n          delay: true,                                                                                                 // 1678\n          from: calculateAnchorStyles(outAnchor)                                                                       // 1679\n        });                                                                                                            // 1680\n                                                                                                                       // 1681\n        // read the comment within `prepareRegularAnimation` to understand                                             // 1682\n        // why this check is necessary                                                                                 // 1683\n        return animator.$$willAnimate ? animator : null;                                                               // 1684\n      }                                                                                                                // 1685\n                                                                                                                       // 1686\n      function getClassVal(element) {                                                                                  // 1687\n        return element.attr('class') || '';                                                                            // 1688\n      }                                                                                                                // 1689\n                                                                                                                       // 1690\n      function prepareInAnimation() {                                                                                  // 1691\n        var endingClasses = filterCssClasses(getClassVal(inAnchor));                                                   // 1692\n        var toAdd = getUniqueValues(endingClasses, startingClasses);                                                   // 1693\n        var toRemove = getUniqueValues(startingClasses, endingClasses);                                                // 1694\n                                                                                                                       // 1695\n        var animator = $animateCss(clone, {                                                                            // 1696\n          to: calculateAnchorStyles(inAnchor),                                                                         // 1697\n          addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,                                                             // 1698\n          removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,                                                      // 1699\n          delay: true                                                                                                  // 1700\n        });                                                                                                            // 1701\n                                                                                                                       // 1702\n        // read the comment within `prepareRegularAnimation` to understand                                             // 1703\n        // why this check is necessary                                                                                 // 1704\n        return animator.$$willAnimate ? animator : null;                                                               // 1705\n      }                                                                                                                // 1706\n                                                                                                                       // 1707\n      function end() {                                                                                                 // 1708\n        clone.remove();                                                                                                // 1709\n        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);                                                             // 1710\n        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);                                                              // 1711\n      }                                                                                                                // 1712\n    }                                                                                                                  // 1713\n                                                                                                                       // 1714\n    function prepareFromToAnchorAnimation(from, to, classes, anchors) {                                                // 1715\n      var fromAnimation = prepareRegularAnimation(from, noop);                                                         // 1716\n      var toAnimation = prepareRegularAnimation(to, noop);                                                             // 1717\n                                                                                                                       // 1718\n      var anchorAnimations = [];                                                                                       // 1719\n      forEach(anchors, function(anchor) {                                                                              // 1720\n        var outElement = anchor['out'];                                                                                // 1721\n        var inElement = anchor['in'];                                                                                  // 1722\n        var animator = prepareAnchoredAnimation(classes, outElement, inElement);                                       // 1723\n        if (animator) {                                                                                                // 1724\n          anchorAnimations.push(animator);                                                                             // 1725\n        }                                                                                                              // 1726\n      });                                                                                                              // 1727\n                                                                                                                       // 1728\n      // no point in doing anything when there are no elements to animate                                              // 1729\n      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;                                     // 1730\n                                                                                                                       // 1731\n      return {                                                                                                         // 1732\n        start: function() {                                                                                            // 1733\n          var animationRunners = [];                                                                                   // 1734\n                                                                                                                       // 1735\n          if (fromAnimation) {                                                                                         // 1736\n            animationRunners.push(fromAnimation.start());                                                              // 1737\n          }                                                                                                            // 1738\n                                                                                                                       // 1739\n          if (toAnimation) {                                                                                           // 1740\n            animationRunners.push(toAnimation.start());                                                                // 1741\n          }                                                                                                            // 1742\n                                                                                                                       // 1743\n          forEach(anchorAnimations, function(animation) {                                                              // 1744\n            animationRunners.push(animation.start());                                                                  // 1745\n          });                                                                                                          // 1746\n                                                                                                                       // 1747\n          var runner = new $$AnimateRunner({                                                                           // 1748\n            end: endFn,                                                                                                // 1749\n            cancel: endFn // CSS-driven animations cannot be cancelled, only ended                                     // 1750\n          });                                                                                                          // 1751\n                                                                                                                       // 1752\n          $$AnimateRunner.all(animationRunners, function(status) {                                                     // 1753\n            runner.complete(status);                                                                                   // 1754\n          });                                                                                                          // 1755\n                                                                                                                       // 1756\n          return runner;                                                                                               // 1757\n                                                                                                                       // 1758\n          function endFn() {                                                                                           // 1759\n            forEach(animationRunners, function(runner) {                                                               // 1760\n              runner.end();                                                                                            // 1761\n            });                                                                                                        // 1762\n          }                                                                                                            // 1763\n        }                                                                                                              // 1764\n      };                                                                                                               // 1765\n    }                                                                                                                  // 1766\n                                                                                                                       // 1767\n    function prepareRegularAnimation(animationDetails) {                                                               // 1768\n      var element = animationDetails.element;                                                                          // 1769\n      var options = animationDetails.options || {};                                                                    // 1770\n                                                                                                                       // 1771\n      if (animationDetails.structural) {                                                                               // 1772\n        options.event = animationDetails.event;                                                                        // 1773\n        options.structural = true;                                                                                     // 1774\n        options.applyClassesEarly = true;                                                                              // 1775\n                                                                                                                       // 1776\n        // we special case the leave animation since we want to ensure that                                            // 1777\n        // the element is removed as soon as the animation is over. Otherwise                                          // 1778\n        // a flicker might appear or the element may not be removed at all                                             // 1779\n        if (animationDetails.event === 'leave') {                                                                      // 1780\n          options.onDone = options.domOperation;                                                                       // 1781\n        }                                                                                                              // 1782\n      }                                                                                                                // 1783\n                                                                                                                       // 1784\n      // We assign the preparationClasses as the actual animation event since                                          // 1785\n      // the internals of $animateCss will just suffix the event token values                                          // 1786\n      // with `-active` to trigger the animation.                                                                      // 1787\n      if (options.preparationClasses) {                                                                                // 1788\n        options.event = concatWithSpace(options.event, options.preparationClasses);                                    // 1789\n      }                                                                                                                // 1790\n                                                                                                                       // 1791\n      var animator = $animateCss(element, options);                                                                    // 1792\n                                                                                                                       // 1793\n      // the driver lookup code inside of $$animation attempts to spawn a                                              // 1794\n      // driver one by one until a driver returns a.$$willAnimate animator object.                                     // 1795\n      // $animateCss will always return an object, however, it will pass in                                            // 1796\n      // a flag as a hint as to whether an animation was detected or not                                               // 1797\n      return animator.$$willAnimate ? animator : null;                                                                 // 1798\n    }                                                                                                                  // 1799\n  }];                                                                                                                  // 1800\n}];                                                                                                                    // 1801\n                                                                                                                       // 1802\n// TODO(matsko): use caching here to speed things up for detection                                                     // 1803\n// TODO(matsko): add documentation                                                                                     // 1804\n//  by the time...                                                                                                     // 1805\n                                                                                                                       // 1806\nvar $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {                                            // 1807\n  this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',                                                             // 1808\n       function($injector,   $$AnimateRunner,   $$jqLite) {                                                            // 1809\n                                                                                                                       // 1810\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);                                                // 1811\n         // $animateJs(element, 'enter');                                                                              // 1812\n    return function(element, event, classes, options) {                                                                // 1813\n      var animationClosed = false;                                                                                     // 1814\n                                                                                                                       // 1815\n      // the `classes` argument is optional and if it is not used                                                      // 1816\n      // then the classes will be resolved from the element's className                                                // 1817\n      // property as well as options.addClass/options.removeClass.                                                     // 1818\n      if (arguments.length === 3 && isObject(classes)) {                                                               // 1819\n        options = classes;                                                                                             // 1820\n        classes = null;                                                                                                // 1821\n      }                                                                                                                // 1822\n                                                                                                                       // 1823\n      options = prepareAnimationOptions(options);                                                                      // 1824\n      if (!classes) {                                                                                                  // 1825\n        classes = element.attr('class') || '';                                                                         // 1826\n        if (options.addClass) {                                                                                        // 1827\n          classes += ' ' + options.addClass;                                                                           // 1828\n        }                                                                                                              // 1829\n        if (options.removeClass) {                                                                                     // 1830\n          classes += ' ' + options.removeClass;                                                                        // 1831\n        }                                                                                                              // 1832\n      }                                                                                                                // 1833\n                                                                                                                       // 1834\n      var classesToAdd = options.addClass;                                                                             // 1835\n      var classesToRemove = options.removeClass;                                                                       // 1836\n                                                                                                                       // 1837\n      // the lookupAnimations function returns a series of animation objects that are                                  // 1838\n      // matched up with one or more of the CSS classes. These animation objects are                                   // 1839\n      // defined via the module.animation factory function. If nothing is detected then                                // 1840\n      // we don't return anything which then makes $animation query the next driver.                                   // 1841\n      var animations = lookupAnimations(classes);                                                                      // 1842\n      var before, after;                                                                                               // 1843\n      if (animations.length) {                                                                                         // 1844\n        var afterFn, beforeFn;                                                                                         // 1845\n        if (event == 'leave') {                                                                                        // 1846\n          beforeFn = 'leave';                                                                                          // 1847\n          afterFn = 'afterLeave'; // TODO(matsko): get rid of this                                                     // 1848\n        } else {                                                                                                       // 1849\n          beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);                                       // 1850\n          afterFn = event;                                                                                             // 1851\n        }                                                                                                              // 1852\n                                                                                                                       // 1853\n        if (event !== 'enter' && event !== 'move') {                                                                   // 1854\n          before = packageAnimations(element, event, options, animations, beforeFn);                                   // 1855\n        }                                                                                                              // 1856\n        after  = packageAnimations(element, event, options, animations, afterFn);                                      // 1857\n      }                                                                                                                // 1858\n                                                                                                                       // 1859\n      // no matching animations                                                                                        // 1860\n      if (!before && !after) return;                                                                                   // 1861\n                                                                                                                       // 1862\n      function applyOptions() {                                                                                        // 1863\n        options.domOperation();                                                                                        // 1864\n        applyAnimationClasses(element, options);                                                                       // 1865\n      }                                                                                                                // 1866\n                                                                                                                       // 1867\n      function close() {                                                                                               // 1868\n        animationClosed = true;                                                                                        // 1869\n        applyOptions();                                                                                                // 1870\n        applyAnimationStyles(element, options);                                                                        // 1871\n      }                                                                                                                // 1872\n                                                                                                                       // 1873\n      var runner;                                                                                                      // 1874\n                                                                                                                       // 1875\n      return {                                                                                                         // 1876\n        $$willAnimate: true,                                                                                           // 1877\n        end: function() {                                                                                              // 1878\n          if (runner) {                                                                                                // 1879\n            runner.end();                                                                                              // 1880\n          } else {                                                                                                     // 1881\n            close();                                                                                                   // 1882\n            runner = new $$AnimateRunner();                                                                            // 1883\n            runner.complete(true);                                                                                     // 1884\n          }                                                                                                            // 1885\n          return runner;                                                                                               // 1886\n        },                                                                                                             // 1887\n        start: function() {                                                                                            // 1888\n          if (runner) {                                                                                                // 1889\n            return runner;                                                                                             // 1890\n          }                                                                                                            // 1891\n                                                                                                                       // 1892\n          runner = new $$AnimateRunner();                                                                              // 1893\n          var closeActiveAnimations;                                                                                   // 1894\n          var chain = [];                                                                                              // 1895\n                                                                                                                       // 1896\n          if (before) {                                                                                                // 1897\n            chain.push(function(fn) {                                                                                  // 1898\n              closeActiveAnimations = before(fn);                                                                      // 1899\n            });                                                                                                        // 1900\n          }                                                                                                            // 1901\n                                                                                                                       // 1902\n          if (chain.length) {                                                                                          // 1903\n            chain.push(function(fn) {                                                                                  // 1904\n              applyOptions();                                                                                          // 1905\n              fn(true);                                                                                                // 1906\n            });                                                                                                        // 1907\n          } else {                                                                                                     // 1908\n            applyOptions();                                                                                            // 1909\n          }                                                                                                            // 1910\n                                                                                                                       // 1911\n          if (after) {                                                                                                 // 1912\n            chain.push(function(fn) {                                                                                  // 1913\n              closeActiveAnimations = after(fn);                                                                       // 1914\n            });                                                                                                        // 1915\n          }                                                                                                            // 1916\n                                                                                                                       // 1917\n          runner.setHost({                                                                                             // 1918\n            end: function() {                                                                                          // 1919\n              endAnimations();                                                                                         // 1920\n            },                                                                                                         // 1921\n            cancel: function() {                                                                                       // 1922\n              endAnimations(true);                                                                                     // 1923\n            }                                                                                                          // 1924\n          });                                                                                                          // 1925\n                                                                                                                       // 1926\n          $$AnimateRunner.chain(chain, onComplete);                                                                    // 1927\n          return runner;                                                                                               // 1928\n                                                                                                                       // 1929\n          function onComplete(success) {                                                                               // 1930\n            close(success);                                                                                            // 1931\n            runner.complete(success);                                                                                  // 1932\n          }                                                                                                            // 1933\n                                                                                                                       // 1934\n          function endAnimations(cancelled) {                                                                          // 1935\n            if (!animationClosed) {                                                                                    // 1936\n              (closeActiveAnimations || noop)(cancelled);                                                              // 1937\n              onComplete(cancelled);                                                                                   // 1938\n            }                                                                                                          // 1939\n          }                                                                                                            // 1940\n        }                                                                                                              // 1941\n      };                                                                                                               // 1942\n                                                                                                                       // 1943\n      function executeAnimationFn(fn, element, event, options, onDone) {                                               // 1944\n        var args;                                                                                                      // 1945\n        switch (event) {                                                                                               // 1946\n          case 'animate':                                                                                              // 1947\n            args = [element, options.from, options.to, onDone];                                                        // 1948\n            break;                                                                                                     // 1949\n                                                                                                                       // 1950\n          case 'setClass':                                                                                             // 1951\n            args = [element, classesToAdd, classesToRemove, onDone];                                                   // 1952\n            break;                                                                                                     // 1953\n                                                                                                                       // 1954\n          case 'addClass':                                                                                             // 1955\n            args = [element, classesToAdd, onDone];                                                                    // 1956\n            break;                                                                                                     // 1957\n                                                                                                                       // 1958\n          case 'removeClass':                                                                                          // 1959\n            args = [element, classesToRemove, onDone];                                                                 // 1960\n            break;                                                                                                     // 1961\n                                                                                                                       // 1962\n          default:                                                                                                     // 1963\n            args = [element, onDone];                                                                                  // 1964\n            break;                                                                                                     // 1965\n        }                                                                                                              // 1966\n                                                                                                                       // 1967\n        args.push(options);                                                                                            // 1968\n                                                                                                                       // 1969\n        var value = fn.apply(fn, args);                                                                                // 1970\n        if (value) {                                                                                                   // 1971\n          if (isFunction(value.start)) {                                                                               // 1972\n            value = value.start();                                                                                     // 1973\n          }                                                                                                            // 1974\n                                                                                                                       // 1975\n          if (value instanceof $$AnimateRunner) {                                                                      // 1976\n            value.done(onDone);                                                                                        // 1977\n          } else if (isFunction(value)) {                                                                              // 1978\n            // optional onEnd / onCancel callback                                                                      // 1979\n            return value;                                                                                              // 1980\n          }                                                                                                            // 1981\n        }                                                                                                              // 1982\n                                                                                                                       // 1983\n        return noop;                                                                                                   // 1984\n      }                                                                                                                // 1985\n                                                                                                                       // 1986\n      function groupEventedAnimations(element, event, options, animations, fnName) {                                   // 1987\n        var operations = [];                                                                                           // 1988\n        forEach(animations, function(ani) {                                                                            // 1989\n          var animation = ani[fnName];                                                                                 // 1990\n          if (!animation) return;                                                                                      // 1991\n                                                                                                                       // 1992\n          // note that all of these animations will run in parallel                                                    // 1993\n          operations.push(function() {                                                                                 // 1994\n            var runner;                                                                                                // 1995\n            var endProgressCb;                                                                                         // 1996\n                                                                                                                       // 1997\n            var resolved = false;                                                                                      // 1998\n            var onAnimationComplete = function(rejected) {                                                             // 1999\n              if (!resolved) {                                                                                         // 2000\n                resolved = true;                                                                                       // 2001\n                (endProgressCb || noop)(rejected);                                                                     // 2002\n                runner.complete(!rejected);                                                                            // 2003\n              }                                                                                                        // 2004\n            };                                                                                                         // 2005\n                                                                                                                       // 2006\n            runner = new $$AnimateRunner({                                                                             // 2007\n              end: function() {                                                                                        // 2008\n                onAnimationComplete();                                                                                 // 2009\n              },                                                                                                       // 2010\n              cancel: function() {                                                                                     // 2011\n                onAnimationComplete(true);                                                                             // 2012\n              }                                                                                                        // 2013\n            });                                                                                                        // 2014\n                                                                                                                       // 2015\n            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {                  // 2016\n              var cancelled = result === false;                                                                        // 2017\n              onAnimationComplete(cancelled);                                                                          // 2018\n            });                                                                                                        // 2019\n                                                                                                                       // 2020\n            return runner;                                                                                             // 2021\n          });                                                                                                          // 2022\n        });                                                                                                            // 2023\n                                                                                                                       // 2024\n        return operations;                                                                                             // 2025\n      }                                                                                                                // 2026\n                                                                                                                       // 2027\n      function packageAnimations(element, event, options, animations, fnName) {                                        // 2028\n        var operations = groupEventedAnimations(element, event, options, animations, fnName);                          // 2029\n        if (operations.length === 0) {                                                                                 // 2030\n          var a,b;                                                                                                     // 2031\n          if (fnName === 'beforeSetClass') {                                                                           // 2032\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');              // 2033\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');                    // 2034\n          } else if (fnName === 'setClass') {                                                                          // 2035\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');                    // 2036\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');                          // 2037\n          }                                                                                                            // 2038\n                                                                                                                       // 2039\n          if (a) {                                                                                                     // 2040\n            operations = operations.concat(a);                                                                         // 2041\n          }                                                                                                            // 2042\n          if (b) {                                                                                                     // 2043\n            operations = operations.concat(b);                                                                         // 2044\n          }                                                                                                            // 2045\n        }                                                                                                              // 2046\n                                                                                                                       // 2047\n        if (operations.length === 0) return;                                                                           // 2048\n                                                                                                                       // 2049\n        // TODO(matsko): add documentation                                                                             // 2050\n        return function startAnimation(callback) {                                                                     // 2051\n          var runners = [];                                                                                            // 2052\n          if (operations.length) {                                                                                     // 2053\n            forEach(operations, function(animateFn) {                                                                  // 2054\n              runners.push(animateFn());                                                                               // 2055\n            });                                                                                                        // 2056\n          }                                                                                                            // 2057\n                                                                                                                       // 2058\n          runners.length ? $$AnimateRunner.all(runners, callback) : callback();                                        // 2059\n                                                                                                                       // 2060\n          return function endFn(reject) {                                                                              // 2061\n            forEach(runners, function(runner) {                                                                        // 2062\n              reject ? runner.cancel() : runner.end();                                                                 // 2063\n            });                                                                                                        // 2064\n          };                                                                                                           // 2065\n        };                                                                                                             // 2066\n      }                                                                                                                // 2067\n    };                                                                                                                 // 2068\n                                                                                                                       // 2069\n    function lookupAnimations(classes) {                                                                               // 2070\n      classes = isArray(classes) ? classes : classes.split(' ');                                                       // 2071\n      var matches = [], flagMap = {};                                                                                  // 2072\n      for (var i=0; i < classes.length; i++) {                                                                         // 2073\n        var klass = classes[i],                                                                                        // 2074\n            animationFactory = $animateProvider.$$registeredAnimations[klass];                                         // 2075\n        if (animationFactory && !flagMap[klass]) {                                                                     // 2076\n          matches.push($injector.get(animationFactory));                                                               // 2077\n          flagMap[klass] = true;                                                                                       // 2078\n        }                                                                                                              // 2079\n      }                                                                                                                // 2080\n      return matches;                                                                                                  // 2081\n    }                                                                                                                  // 2082\n  }];                                                                                                                  // 2083\n}];                                                                                                                    // 2084\n                                                                                                                       // 2085\nvar $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {                                // 2086\n  $$animationProvider.drivers.push('$$animateJsDriver');                                                               // 2087\n  this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {                              // 2088\n    return function initDriverFn(animationDetails) {                                                                   // 2089\n      if (animationDetails.from && animationDetails.to) {                                                              // 2090\n        var fromAnimation = prepareAnimation(animationDetails.from);                                                   // 2091\n        var toAnimation = prepareAnimation(animationDetails.to);                                                       // 2092\n        if (!fromAnimation && !toAnimation) return;                                                                    // 2093\n                                                                                                                       // 2094\n        return {                                                                                                       // 2095\n          start: function() {                                                                                          // 2096\n            var animationRunners = [];                                                                                 // 2097\n                                                                                                                       // 2098\n            if (fromAnimation) {                                                                                       // 2099\n              animationRunners.push(fromAnimation.start());                                                            // 2100\n            }                                                                                                          // 2101\n                                                                                                                       // 2102\n            if (toAnimation) {                                                                                         // 2103\n              animationRunners.push(toAnimation.start());                                                              // 2104\n            }                                                                                                          // 2105\n                                                                                                                       // 2106\n            $$AnimateRunner.all(animationRunners, done);                                                               // 2107\n                                                                                                                       // 2108\n            var runner = new $$AnimateRunner({                                                                         // 2109\n              end: endFnFactory(),                                                                                     // 2110\n              cancel: endFnFactory()                                                                                   // 2111\n            });                                                                                                        // 2112\n                                                                                                                       // 2113\n            return runner;                                                                                             // 2114\n                                                                                                                       // 2115\n            function endFnFactory() {                                                                                  // 2116\n              return function() {                                                                                      // 2117\n                forEach(animationRunners, function(runner) {                                                           // 2118\n                  // at this point we cannot cancel animations for groups just yet. 1.5+                               // 2119\n                  runner.end();                                                                                        // 2120\n                });                                                                                                    // 2121\n              };                                                                                                       // 2122\n            }                                                                                                          // 2123\n                                                                                                                       // 2124\n            function done(status) {                                                                                    // 2125\n              runner.complete(status);                                                                                 // 2126\n            }                                                                                                          // 2127\n          }                                                                                                            // 2128\n        };                                                                                                             // 2129\n      } else {                                                                                                         // 2130\n        return prepareAnimation(animationDetails);                                                                     // 2131\n      }                                                                                                                // 2132\n    };                                                                                                                 // 2133\n                                                                                                                       // 2134\n    function prepareAnimation(animationDetails) {                                                                      // 2135\n      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations                // 2136\n      var element = animationDetails.element;                                                                          // 2137\n      var event = animationDetails.event;                                                                              // 2138\n      var options = animationDetails.options;                                                                          // 2139\n      var classes = animationDetails.classes;                                                                          // 2140\n      return $$animateJs(element, event, classes, options);                                                            // 2141\n    }                                                                                                                  // 2142\n  }];                                                                                                                  // 2143\n}];                                                                                                                    // 2144\n                                                                                                                       // 2145\nvar NG_ANIMATE_ATTR_NAME = 'data-ng-animate';                                                                          // 2146\nvar NG_ANIMATE_PIN_DATA = '$ngAnimatePin';                                                                             // 2147\nvar $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {                                         // 2148\n  var PRE_DIGEST_STATE = 1;                                                                                            // 2149\n  var RUNNING_STATE = 2;                                                                                               // 2150\n  var ONE_SPACE = ' ';                                                                                                 // 2151\n                                                                                                                       // 2152\n  var rules = this.rules = {                                                                                           // 2153\n    skip: [],                                                                                                          // 2154\n    cancel: [],                                                                                                        // 2155\n    join: []                                                                                                           // 2156\n  };                                                                                                                   // 2157\n                                                                                                                       // 2158\n  function makeTruthyCssClassMap(classString) {                                                                        // 2159\n    if (!classString) {                                                                                                // 2160\n      return null;                                                                                                     // 2161\n    }                                                                                                                  // 2162\n                                                                                                                       // 2163\n    var keys = classString.split(ONE_SPACE);                                                                           // 2164\n    var map = Object.create(null);                                                                                     // 2165\n                                                                                                                       // 2166\n    forEach(keys, function(key) {                                                                                      // 2167\n      map[key] = true;                                                                                                 // 2168\n    });                                                                                                                // 2169\n    return map;                                                                                                        // 2170\n  }                                                                                                                    // 2171\n                                                                                                                       // 2172\n  function hasMatchingClasses(newClassString, currentClassString) {                                                    // 2173\n    if (newClassString && currentClassString) {                                                                        // 2174\n      var currentClassMap = makeTruthyCssClassMap(currentClassString);                                                 // 2175\n      return newClassString.split(ONE_SPACE).some(function(className) {                                                // 2176\n        return currentClassMap[className];                                                                             // 2177\n      });                                                                                                              // 2178\n    }                                                                                                                  // 2179\n  }                                                                                                                    // 2180\n                                                                                                                       // 2181\n  function isAllowed(ruleType, element, currentAnimation, previousAnimation) {                                         // 2182\n    return rules[ruleType].some(function(fn) {                                                                         // 2183\n      return fn(element, currentAnimation, previousAnimation);                                                         // 2184\n    });                                                                                                                // 2185\n  }                                                                                                                    // 2186\n                                                                                                                       // 2187\n  function hasAnimationClasses(animation, and) {                                                                       // 2188\n    var a = (animation.addClass || '').length > 0;                                                                     // 2189\n    var b = (animation.removeClass || '').length > 0;                                                                  // 2190\n    return and ? a && b : a || b;                                                                                      // 2191\n  }                                                                                                                    // 2192\n                                                                                                                       // 2193\n  rules.join.push(function(element, newAnimation, currentAnimation) {                                                  // 2194\n    // if the new animation is class-based then we can just tack that on                                               // 2195\n    return !newAnimation.structural && hasAnimationClasses(newAnimation);                                              // 2196\n  });                                                                                                                  // 2197\n                                                                                                                       // 2198\n  rules.skip.push(function(element, newAnimation, currentAnimation) {                                                  // 2199\n    // there is no need to animate anything if no classes are being added and                                          // 2200\n    // there is no structural animation that will be triggered                                                         // 2201\n    return !newAnimation.structural && !hasAnimationClasses(newAnimation);                                             // 2202\n  });                                                                                                                  // 2203\n                                                                                                                       // 2204\n  rules.skip.push(function(element, newAnimation, currentAnimation) {                                                  // 2205\n    // why should we trigger a new structural animation if the element will                                            // 2206\n    // be removed from the DOM anyway?                                                                                 // 2207\n    return currentAnimation.event == 'leave' && newAnimation.structural;                                               // 2208\n  });                                                                                                                  // 2209\n                                                                                                                       // 2210\n  rules.skip.push(function(element, newAnimation, currentAnimation) {                                                  // 2211\n    // if there is an ongoing current animation then don't even bother running the class-based animation               // 2212\n    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;        // 2213\n  });                                                                                                                  // 2214\n                                                                                                                       // 2215\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {                                                // 2216\n    // there can never be two structural animations running at the same time                                           // 2217\n    return currentAnimation.structural && newAnimation.structural;                                                     // 2218\n  });                                                                                                                  // 2219\n                                                                                                                       // 2220\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {                                                // 2221\n    // if the previous animation is already running, but the new animation will                                        // 2222\n    // be triggered, but the new animation is structural                                                               // 2223\n    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;                                        // 2224\n  });                                                                                                                  // 2225\n                                                                                                                       // 2226\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {                                                // 2227\n    // cancel the animation if classes added / removed in both animation cancel each other out,                        // 2228\n    // but only if the current animation isn't structural                                                              // 2229\n                                                                                                                       // 2230\n    if (currentAnimation.structural) return false;                                                                     // 2231\n                                                                                                                       // 2232\n    var nA = newAnimation.addClass;                                                                                    // 2233\n    var nR = newAnimation.removeClass;                                                                                 // 2234\n    var cA = currentAnimation.addClass;                                                                                // 2235\n    var cR = currentAnimation.removeClass;                                                                             // 2236\n                                                                                                                       // 2237\n    // early detection to save the global CPU shortage :)                                                              // 2238\n    if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {                                // 2239\n      return false;                                                                                                    // 2240\n    }                                                                                                                  // 2241\n                                                                                                                       // 2242\n    return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);                                                   // 2243\n  });                                                                                                                  // 2244\n                                                                                                                       // 2245\n  this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap',                                        // 2246\n               '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',                      // 2247\n       function($$rAF,   $rootScope,   $rootElement,   $document,   $$HashMap,                                         // 2248\n                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite,   $$forceReflow) {                     // 2249\n                                                                                                                       // 2250\n    var activeAnimationsLookup = new $$HashMap();                                                                      // 2251\n    var disabledElementsLookup = new $$HashMap();                                                                      // 2252\n    var animationsEnabled = null;                                                                                      // 2253\n                                                                                                                       // 2254\n    function postDigestTaskFactory() {                                                                                 // 2255\n      var postDigestCalled = false;                                                                                    // 2256\n      return function(fn) {                                                                                            // 2257\n        // we only issue a call to postDigest before                                                                   // 2258\n        // it has first passed. This prevents any callbacks                                                            // 2259\n        // from not firing once the animation has completed                                                            // 2260\n        // since it will be out of the digest cycle.                                                                   // 2261\n        if (postDigestCalled) {                                                                                        // 2262\n          fn();                                                                                                        // 2263\n        } else {                                                                                                       // 2264\n          $rootScope.$$postDigest(function() {                                                                         // 2265\n            postDigestCalled = true;                                                                                   // 2266\n            fn();                                                                                                      // 2267\n          });                                                                                                          // 2268\n        }                                                                                                              // 2269\n      };                                                                                                               // 2270\n    }                                                                                                                  // 2271\n                                                                                                                       // 2272\n    // Wait until all directive and route-related templates are downloaded and                                         // 2273\n    // compiled. The $templateRequest.totalPendingRequests variable keeps track of                                     // 2274\n    // all of the remote templates being currently downloaded. If there are no                                         // 2275\n    // templates currently downloading then the watcher will still fire anyway.                                        // 2276\n    var deregisterWatch = $rootScope.$watch(                                                                           // 2277\n      function() { return $templateRequest.totalPendingRequests === 0; },                                              // 2278\n      function(isEmpty) {                                                                                              // 2279\n        if (!isEmpty) return;                                                                                          // 2280\n        deregisterWatch();                                                                                             // 2281\n                                                                                                                       // 2282\n        // Now that all templates have been downloaded, $animate will wait until                                       // 2283\n        // the post digest queue is empty before enabling animations. By having two                                    // 2284\n        // calls to $postDigest calls we can ensure that the flag is enabled at the                                    // 2285\n        // very end of the post digest queue. Since all of the animations in $animate                                  // 2286\n        // use $postDigest, it's important that the code below executes at the end.                                    // 2287\n        // This basically means that the page is fully downloaded and compiled before                                  // 2288\n        // any animations are triggered.                                                                               // 2289\n        $rootScope.$$postDigest(function() {                                                                           // 2290\n          $rootScope.$$postDigest(function() {                                                                         // 2291\n            // we check for null directly in the event that the application already called                             // 2292\n            // .enabled() with whatever arguments that it provided it with                                             // 2293\n            if (animationsEnabled === null) {                                                                          // 2294\n              animationsEnabled = true;                                                                                // 2295\n            }                                                                                                          // 2296\n          });                                                                                                          // 2297\n        });                                                                                                            // 2298\n      }                                                                                                                // 2299\n    );                                                                                                                 // 2300\n                                                                                                                       // 2301\n    var callbackRegistry = {};                                                                                         // 2302\n                                                                                                                       // 2303\n    // remember that the classNameFilter is set during the provider/config                                             // 2304\n    // stage therefore we can optimize here and setup a helper function                                                // 2305\n    var classNameFilter = $animateProvider.classNameFilter();                                                          // 2306\n    var isAnimatableClassName = !classNameFilter                                                                       // 2307\n              ? function() { return true; }                                                                            // 2308\n              : function(className) {                                                                                  // 2309\n                return classNameFilter.test(className);                                                                // 2310\n              };                                                                                                       // 2311\n                                                                                                                       // 2312\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);                                                // 2313\n                                                                                                                       // 2314\n    function normalizeAnimationDetails(element, animation) {                                                           // 2315\n      return mergeAnimationDetails(element, animation, {});                                                            // 2316\n    }                                                                                                                  // 2317\n                                                                                                                       // 2318\n    // IE9-11 has no method \"contains\" in SVG element and in Node.prototype. Bug #10259.                               // 2319\n    var contains = Node.prototype.contains || function(arg) {                                                          // 2320\n      // jshint bitwise: false                                                                                         // 2321\n      return this === arg || !!(this.compareDocumentPosition(arg) & 16);                                               // 2322\n      // jshint bitwise: true                                                                                          // 2323\n    };                                                                                                                 // 2324\n                                                                                                                       // 2325\n    function findCallbacks(parent, element, event) {                                                                   // 2326\n      var targetNode = getDomNode(element);                                                                            // 2327\n      var targetParentNode = getDomNode(parent);                                                                       // 2328\n                                                                                                                       // 2329\n      var matches = [];                                                                                                // 2330\n      var entries = callbackRegistry[event];                                                                           // 2331\n      if (entries) {                                                                                                   // 2332\n        forEach(entries, function(entry) {                                                                             // 2333\n          if (contains.call(entry.node, targetNode)) {                                                                 // 2334\n            matches.push(entry.callback);                                                                              // 2335\n          } else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {                               // 2336\n            matches.push(entry.callback);                                                                              // 2337\n          }                                                                                                            // 2338\n        });                                                                                                            // 2339\n      }                                                                                                                // 2340\n                                                                                                                       // 2341\n      return matches;                                                                                                  // 2342\n    }                                                                                                                  // 2343\n                                                                                                                       // 2344\n    var $animate = {                                                                                                   // 2345\n      on: function(event, container, callback) {                                                                       // 2346\n        var node = extractElementNode(container);                                                                      // 2347\n        callbackRegistry[event] = callbackRegistry[event] || [];                                                       // 2348\n        callbackRegistry[event].push({                                                                                 // 2349\n          node: node,                                                                                                  // 2350\n          callback: callback                                                                                           // 2351\n        });                                                                                                            // 2352\n                                                                                                                       // 2353\n        // Remove the callback when the element is removed from the DOM                                                // 2354\n        jqLite(container).on('$destroy', function() {                                                                  // 2355\n          $animate.off(event, container, callback);                                                                    // 2356\n        });                                                                                                            // 2357\n      },                                                                                                               // 2358\n                                                                                                                       // 2359\n      off: function(event, container, callback) {                                                                      // 2360\n        var entries = callbackRegistry[event];                                                                         // 2361\n        if (!entries) return;                                                                                          // 2362\n                                                                                                                       // 2363\n        callbackRegistry[event] = arguments.length === 1                                                               // 2364\n            ? null                                                                                                     // 2365\n            : filterFromRegistry(entries, container, callback);                                                        // 2366\n                                                                                                                       // 2367\n        function filterFromRegistry(list, matchContainer, matchCallback) {                                             // 2368\n          var containerNode = extractElementNode(matchContainer);                                                      // 2369\n          return list.filter(function(entry) {                                                                         // 2370\n            var isMatch = entry.node === containerNode &&                                                              // 2371\n                            (!matchCallback || entry.callback === matchCallback);                                      // 2372\n            return !isMatch;                                                                                           // 2373\n          });                                                                                                          // 2374\n        }                                                                                                              // 2375\n      },                                                                                                               // 2376\n                                                                                                                       // 2377\n      pin: function(element, parentElement) {                                                                          // 2378\n        assertArg(isElement(element), 'element', 'not an element');                                                    // 2379\n        assertArg(isElement(parentElement), 'parentElement', 'not an element');                                        // 2380\n        element.data(NG_ANIMATE_PIN_DATA, parentElement);                                                              // 2381\n      },                                                                                                               // 2382\n                                                                                                                       // 2383\n      push: function(element, event, options, domOperation) {                                                          // 2384\n        options = options || {};                                                                                       // 2385\n        options.domOperation = domOperation;                                                                           // 2386\n        return queueAnimation(element, event, options);                                                                // 2387\n      },                                                                                                               // 2388\n                                                                                                                       // 2389\n      // this method has four signatures:                                                                              // 2390\n      //  () - global getter                                                                                           // 2391\n      //  (bool) - global setter                                                                                       // 2392\n      //  (element) - element getter                                                                                   // 2393\n      //  (element, bool) - element setter<F37>                                                                        // 2394\n      enabled: function(element, bool) {                                                                               // 2395\n        var argCount = arguments.length;                                                                               // 2396\n                                                                                                                       // 2397\n        if (argCount === 0) {                                                                                          // 2398\n          // () - Global getter                                                                                        // 2399\n          bool = !!animationsEnabled;                                                                                  // 2400\n        } else {                                                                                                       // 2401\n          var hasElement = isElement(element);                                                                         // 2402\n                                                                                                                       // 2403\n          if (!hasElement) {                                                                                           // 2404\n            // (bool) - Global setter                                                                                  // 2405\n            bool = animationsEnabled = !!element;                                                                      // 2406\n          } else {                                                                                                     // 2407\n            var node = getDomNode(element);                                                                            // 2408\n            var recordExists = disabledElementsLookup.get(node);                                                       // 2409\n                                                                                                                       // 2410\n            if (argCount === 1) {                                                                                      // 2411\n              // (element) - Element getter                                                                            // 2412\n              bool = !recordExists;                                                                                    // 2413\n            } else {                                                                                                   // 2414\n              // (element, bool) - Element setter                                                                      // 2415\n              disabledElementsLookup.put(node, !bool);                                                                 // 2416\n            }                                                                                                          // 2417\n          }                                                                                                            // 2418\n        }                                                                                                              // 2419\n                                                                                                                       // 2420\n        return bool;                                                                                                   // 2421\n      }                                                                                                                // 2422\n    };                                                                                                                 // 2423\n                                                                                                                       // 2424\n    return $animate;                                                                                                   // 2425\n                                                                                                                       // 2426\n    function queueAnimation(element, event, initialOptions) {                                                          // 2427\n      // we always make a copy of the options since                                                                    // 2428\n      // there should never be any side effects on                                                                     // 2429\n      // the input data when running `$animateCss`.                                                                    // 2430\n      var options = copy(initialOptions);                                                                              // 2431\n                                                                                                                       // 2432\n      var node, parent;                                                                                                // 2433\n      element = stripCommentsFromElement(element);                                                                     // 2434\n      if (element) {                                                                                                   // 2435\n        node = getDomNode(element);                                                                                    // 2436\n        parent = element.parent();                                                                                     // 2437\n      }                                                                                                                // 2438\n                                                                                                                       // 2439\n      options = prepareAnimationOptions(options);                                                                      // 2440\n                                                                                                                       // 2441\n      // we create a fake runner with a working promise.                                                               // 2442\n      // These methods will become available after the digest has passed                                               // 2443\n      var runner = new $$AnimateRunner();                                                                              // 2444\n                                                                                                                       // 2445\n      // this is used to trigger callbacks in postDigest mode                                                          // 2446\n      var runInNextPostDigestOrNow = postDigestTaskFactory();                                                          // 2447\n                                                                                                                       // 2448\n      if (isArray(options.addClass)) {                                                                                 // 2449\n        options.addClass = options.addClass.join(' ');                                                                 // 2450\n      }                                                                                                                // 2451\n                                                                                                                       // 2452\n      if (options.addClass && !isString(options.addClass)) {                                                           // 2453\n        options.addClass = null;                                                                                       // 2454\n      }                                                                                                                // 2455\n                                                                                                                       // 2456\n      if (isArray(options.removeClass)) {                                                                              // 2457\n        options.removeClass = options.removeClass.join(' ');                                                           // 2458\n      }                                                                                                                // 2459\n                                                                                                                       // 2460\n      if (options.removeClass && !isString(options.removeClass)) {                                                     // 2461\n        options.removeClass = null;                                                                                    // 2462\n      }                                                                                                                // 2463\n                                                                                                                       // 2464\n      if (options.from && !isObject(options.from)) {                                                                   // 2465\n        options.from = null;                                                                                           // 2466\n      }                                                                                                                // 2467\n                                                                                                                       // 2468\n      if (options.to && !isObject(options.to)) {                                                                       // 2469\n        options.to = null;                                                                                             // 2470\n      }                                                                                                                // 2471\n                                                                                                                       // 2472\n      // there are situations where a directive issues an animation for                                                // 2473\n      // a jqLite wrapper that contains only comment nodes... If this                                                  // 2474\n      // happens then there is no way we can perform an animation                                                      // 2475\n      if (!node) {                                                                                                     // 2476\n        close();                                                                                                       // 2477\n        return runner;                                                                                                 // 2478\n      }                                                                                                                // 2479\n                                                                                                                       // 2480\n      var className = [node.className, options.addClass, options.removeClass].join(' ');                               // 2481\n      if (!isAnimatableClassName(className)) {                                                                         // 2482\n        close();                                                                                                       // 2483\n        return runner;                                                                                                 // 2484\n      }                                                                                                                // 2485\n                                                                                                                       // 2486\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;                                               // 2487\n                                                                                                                       // 2488\n      // this is a hard disable of all animations for the application or on                                            // 2489\n      // the element itself, therefore  there is no need to continue further                                           // 2490\n      // past this point if not enabled                                                                                // 2491\n      // Animations are also disabled if the document is currently hidden (page is not visible                         // 2492\n      // to the user), because browsers slow down or do not flush calls to requestAnimationFrame                       // 2493\n      var skipAnimations = !animationsEnabled || $document[0].hidden || disabledElementsLookup.get(node);              // 2494\n      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};                             // 2495\n      var hasExistingAnimation = !!existingAnimation.state;                                                            // 2496\n                                                                                                                       // 2497\n      // there is no point in traversing the same collection of parent ancestors if a followup                         // 2498\n      // animation will be run on the same element that already did all that checking work                             // 2499\n      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {                 // 2500\n        skipAnimations = !areAnimationsAllowed(element, parent, event);                                                // 2501\n      }                                                                                                                // 2502\n                                                                                                                       // 2503\n      if (skipAnimations) {                                                                                            // 2504\n        close();                                                                                                       // 2505\n        return runner;                                                                                                 // 2506\n      }                                                                                                                // 2507\n                                                                                                                       // 2508\n      if (isStructural) {                                                                                              // 2509\n        closeChildAnimations(element);                                                                                 // 2510\n      }                                                                                                                // 2511\n                                                                                                                       // 2512\n      var newAnimation = {                                                                                             // 2513\n        structural: isStructural,                                                                                      // 2514\n        element: element,                                                                                              // 2515\n        event: event,                                                                                                  // 2516\n        addClass: options.addClass,                                                                                    // 2517\n        removeClass: options.removeClass,                                                                              // 2518\n        close: close,                                                                                                  // 2519\n        options: options,                                                                                              // 2520\n        runner: runner                                                                                                 // 2521\n      };                                                                                                               // 2522\n                                                                                                                       // 2523\n      if (hasExistingAnimation) {                                                                                      // 2524\n        var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);                           // 2525\n        if (skipAnimationFlag) {                                                                                       // 2526\n          if (existingAnimation.state === RUNNING_STATE) {                                                             // 2527\n            close();                                                                                                   // 2528\n            return runner;                                                                                             // 2529\n          } else {                                                                                                     // 2530\n            mergeAnimationDetails(element, existingAnimation, newAnimation);                                           // 2531\n            return existingAnimation.runner;                                                                           // 2532\n          }                                                                                                            // 2533\n        }                                                                                                              // 2534\n        var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);                       // 2535\n        if (cancelAnimationFlag) {                                                                                     // 2536\n          if (existingAnimation.state === RUNNING_STATE) {                                                             // 2537\n            // this will end the animation right away and it is safe                                                   // 2538\n            // to do so since the animation is already running and the                                                 // 2539\n            // runner callback code will run in async                                                                  // 2540\n            existingAnimation.runner.end();                                                                            // 2541\n          } else if (existingAnimation.structural) {                                                                   // 2542\n            // this means that the animation is queued into a digest, but                                              // 2543\n            // hasn't started yet. Therefore it is safe to run the close                                               // 2544\n            // method which will call the runner methods in async.                                                     // 2545\n            existingAnimation.close();                                                                                 // 2546\n          } else {                                                                                                     // 2547\n            // this will merge the new animation options into existing animation options                               // 2548\n            mergeAnimationDetails(element, existingAnimation, newAnimation);                                           // 2549\n                                                                                                                       // 2550\n            return existingAnimation.runner;                                                                           // 2551\n          }                                                                                                            // 2552\n        } else {                                                                                                       // 2553\n          // a joined animation means that this animation will take over the existing one                              // 2554\n          // so an example would involve a leave animation taking over an enter. Then when                             // 2555\n          // the postDigest kicks in the enter will be ignored.                                                        // 2556\n          var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);                         // 2557\n          if (joinAnimationFlag) {                                                                                     // 2558\n            if (existingAnimation.state === RUNNING_STATE) {                                                           // 2559\n              normalizeAnimationDetails(element, newAnimation);                                                        // 2560\n            } else {                                                                                                   // 2561\n              applyGeneratedPreparationClasses(element, isStructural ? event : null, options);                         // 2562\n                                                                                                                       // 2563\n              event = newAnimation.event = existingAnimation.event;                                                    // 2564\n              options = mergeAnimationDetails(element, existingAnimation, newAnimation);                               // 2565\n                                                                                                                       // 2566\n              //we return the same runner since only the option values of this animation will                          // 2567\n              //be fed into the `existingAnimation`.                                                                   // 2568\n              return existingAnimation.runner;                                                                         // 2569\n            }                                                                                                          // 2570\n          }                                                                                                            // 2571\n        }                                                                                                              // 2572\n      } else {                                                                                                         // 2573\n        // normalization in this case means that it removes redundant CSS classes that                                 // 2574\n        // already exist (addClass) or do not exist (removeClass) on the element                                       // 2575\n        normalizeAnimationDetails(element, newAnimation);                                                              // 2576\n      }                                                                                                                // 2577\n                                                                                                                       // 2578\n      // when the options are merged and cleaned up we may end up not having to do                                     // 2579\n      // an animation at all, therefore we should check this before issuing a post                                     // 2580\n      // digest callback. Structural animations will always run no matter what.                                        // 2581\n      var isValidAnimation = newAnimation.structural;                                                                  // 2582\n      if (!isValidAnimation) {                                                                                         // 2583\n        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present               // 2584\n        isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)\n                            || hasAnimationClasses(newAnimation);                                                      // 2586\n      }                                                                                                                // 2587\n                                                                                                                       // 2588\n      if (!isValidAnimation) {                                                                                         // 2589\n        close();                                                                                                       // 2590\n        clearElementAnimationState(element);                                                                           // 2591\n        return runner;                                                                                                 // 2592\n      }                                                                                                                // 2593\n                                                                                                                       // 2594\n      // the counter keeps track of cancelled animations                                                               // 2595\n      var counter = (existingAnimation.counter || 0) + 1;                                                              // 2596\n      newAnimation.counter = counter;                                                                                  // 2597\n                                                                                                                       // 2598\n      markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);                                              // 2599\n                                                                                                                       // 2600\n      $rootScope.$$postDigest(function() {                                                                             // 2601\n        var animationDetails = activeAnimationsLookup.get(node);                                                       // 2602\n        var animationCancelled = !animationDetails;                                                                    // 2603\n        animationDetails = animationDetails || {};                                                                     // 2604\n                                                                                                                       // 2605\n        // if addClass/removeClass is called before something like enter then the                                      // 2606\n        // registered parent element may not be present. The code below will ensure                                    // 2607\n        // that a final value for parent element is obtained                                                           // 2608\n        var parentElement = element.parent() || [];                                                                    // 2609\n                                                                                                                       // 2610\n        // animate/structural/class-based animations all have requirements. Otherwise there                            // 2611\n        // is no point in performing an animation. The parent node must also be set.                                   // 2612\n        var isValidAnimation = parentElement.length > 0                                                                // 2613\n                                && (animationDetails.event === 'animate'                                               // 2614\n                                    || animationDetails.structural                                                     // 2615\n                                    || hasAnimationClasses(animationDetails));                                         // 2616\n                                                                                                                       // 2617\n        // this means that the previous animation was cancelled                                                        // 2618\n        // even if the follow-up animation is the same event                                                           // 2619\n        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {                         // 2620\n          // if another animation did not take over then we need                                                       // 2621\n          // to make sure that the domOperation and options are                                                        // 2622\n          // handled accordingly                                                                                       // 2623\n          if (animationCancelled) {                                                                                    // 2624\n            applyAnimationClasses(element, options);                                                                   // 2625\n            applyAnimationStyles(element, options);                                                                    // 2626\n          }                                                                                                            // 2627\n                                                                                                                       // 2628\n          // if the event changed from something like enter to leave then we do                                        // 2629\n          // it, otherwise if it's the same then the end result will be the same too                                   // 2630\n          if (animationCancelled || (isStructural && animationDetails.event !== event)) {                              // 2631\n            options.domOperation();                                                                                    // 2632\n            runner.end();                                                                                              // 2633\n          }                                                                                                            // 2634\n                                                                                                                       // 2635\n          // in the event that the element animation was not cancelled or a follow-up animation                        // 2636\n          // isn't allowed to animate from here then we need to clear the state of the element                         // 2637\n          // so that any future animations won't read the expired animation data.                                      // 2638\n          if (!isValidAnimation) {                                                                                     // 2639\n            clearElementAnimationState(element);                                                                       // 2640\n          }                                                                                                            // 2641\n                                                                                                                       // 2642\n          return;                                                                                                      // 2643\n        }                                                                                                              // 2644\n                                                                                                                       // 2645\n        // this combined multiple class to addClass / removeClass into a setClass event                                // 2646\n        // so long as a structural event did not take over the animation                                               // 2647\n        event = !animationDetails.structural && hasAnimationClasses(animationDetails, true)                            // 2648\n            ? 'setClass'                                                                                               // 2649\n            : animationDetails.event;                                                                                  // 2650\n                                                                                                                       // 2651\n        markElementAnimationState(element, RUNNING_STATE);                                                             // 2652\n        var realRunner = $$animation(element, event, animationDetails.options);                                        // 2653\n                                                                                                                       // 2654\n        realRunner.done(function(status) {                                                                             // 2655\n          close(!status);                                                                                              // 2656\n          var animationDetails = activeAnimationsLookup.get(node);                                                     // 2657\n          if (animationDetails && animationDetails.counter === counter) {                                              // 2658\n            clearElementAnimationState(getDomNode(element));                                                           // 2659\n          }                                                                                                            // 2660\n          notifyProgress(runner, event, 'close', {});                                                                  // 2661\n        });                                                                                                            // 2662\n                                                                                                                       // 2663\n        // this will update the runner's flow-control events based on                                                  // 2664\n        // the `realRunner` object.                                                                                    // 2665\n        runner.setHost(realRunner);                                                                                    // 2666\n        notifyProgress(runner, event, 'start', {});                                                                    // 2667\n      });                                                                                                              // 2668\n                                                                                                                       // 2669\n      return runner;                                                                                                   // 2670\n                                                                                                                       // 2671\n      function notifyProgress(runner, event, phase, data) {                                                            // 2672\n        runInNextPostDigestOrNow(function() {                                                                          // 2673\n          var callbacks = findCallbacks(parent, element, event);                                                       // 2674\n          if (callbacks.length) {                                                                                      // 2675\n            // do not optimize this call here to RAF because                                                           // 2676\n            // we don't know how heavy the callback code here will                                                     // 2677\n            // be and if this code is buffered then this can                                                           // 2678\n            // lead to a performance regression.                                                                       // 2679\n            $$rAF(function() {                                                                                         // 2680\n              forEach(callbacks, function(callback) {                                                                  // 2681\n                callback(element, phase, data);                                                                        // 2682\n              });                                                                                                      // 2683\n            });                                                                                                        // 2684\n          }                                                                                                            // 2685\n        });                                                                                                            // 2686\n        runner.progress(event, phase, data);                                                                           // 2687\n      }                                                                                                                // 2688\n                                                                                                                       // 2689\n      function close(reject) { // jshint ignore:line                                                                   // 2690\n        clearGeneratedClasses(element, options);                                                                       // 2691\n        applyAnimationClasses(element, options);                                                                       // 2692\n        applyAnimationStyles(element, options);                                                                        // 2693\n        options.domOperation();                                                                                        // 2694\n        runner.complete(!reject);                                                                                      // 2695\n      }                                                                                                                // 2696\n    }                                                                                                                  // 2697\n                                                                                                                       // 2698\n    function closeChildAnimations(element) {                                                                           // 2699\n      var node = getDomNode(element);                                                                                  // 2700\n      var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');                                          // 2701\n      forEach(children, function(child) {                                                                              // 2702\n        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));                                                // 2703\n        var animationDetails = activeAnimationsLookup.get(child);                                                      // 2704\n        if (animationDetails) {                                                                                        // 2705\n          switch (state) {                                                                                             // 2706\n            case RUNNING_STATE:                                                                                        // 2707\n              animationDetails.runner.end();                                                                           // 2708\n              /* falls through */                                                                                      // 2709\n            case PRE_DIGEST_STATE:                                                                                     // 2710\n              activeAnimationsLookup.remove(child);                                                                    // 2711\n              break;                                                                                                   // 2712\n          }                                                                                                            // 2713\n        }                                                                                                              // 2714\n      });                                                                                                              // 2715\n    }                                                                                                                  // 2716\n                                                                                                                       // 2717\n    function clearElementAnimationState(element) {                                                                     // 2718\n      var node = getDomNode(element);                                                                                  // 2719\n      node.removeAttribute(NG_ANIMATE_ATTR_NAME);                                                                      // 2720\n      activeAnimationsLookup.remove(node);                                                                             // 2721\n    }                                                                                                                  // 2722\n                                                                                                                       // 2723\n    function isMatchingElement(nodeOrElmA, nodeOrElmB) {                                                               // 2724\n      return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);                                                        // 2725\n    }                                                                                                                  // 2726\n                                                                                                                       // 2727\n    /**                                                                                                                // 2728\n     * This fn returns false if any of the following is true:                                                          // 2729\n     * a) animations on any parent element are disabled, and animations on the element aren't explicitly allowed       // 2730\n     * b) a parent element has an ongoing structural animation, and animateChildren is false                           // 2731\n     * c) the element is not a child of the body                                                                       // 2732\n     * d) the element is not a child of the $rootElement                                                               // 2733\n     */                                                                                                                // 2734\n    function areAnimationsAllowed(element, parentElement, event) {                                                     // 2735\n      var bodyElement = jqLite($document[0].body);                                                                     // 2736\n      var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';             // 2737\n      var rootElementDetected = isMatchingElement(element, $rootElement);                                              // 2738\n      var parentAnimationDetected = false;                                                                             // 2739\n      var animateChildren;                                                                                             // 2740\n      var elementDisabled = disabledElementsLookup.get(getDomNode(element));                                           // 2741\n                                                                                                                       // 2742\n      var parentHost = jqLite.data(element[0], NG_ANIMATE_PIN_DATA);                                                   // 2743\n      if (parentHost) {                                                                                                // 2744\n        parentElement = parentHost;                                                                                    // 2745\n      }                                                                                                                // 2746\n                                                                                                                       // 2747\n      parentElement = getDomNode(parentElement);                                                                       // 2748\n                                                                                                                       // 2749\n      while (parentElement) {                                                                                          // 2750\n        if (!rootElementDetected) {                                                                                    // 2751\n          // angular doesn't want to attempt to animate elements outside of the application                            // 2752\n          // therefore we need to ensure that the rootElement is an ancestor of the current element                    // 2753\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);                                        // 2754\n        }                                                                                                              // 2755\n                                                                                                                       // 2756\n        if (parentElement.nodeType !== ELEMENT_NODE) {                                                                 // 2757\n          // no point in inspecting the #document element                                                              // 2758\n          break;                                                                                                       // 2759\n        }                                                                                                              // 2760\n                                                                                                                       // 2761\n        var details = activeAnimationsLookup.get(parentElement) || {};                                                 // 2762\n        // either an enter, leave or move animation will commence                                                      // 2763\n        // therefore we can't allow any animations to take place                                                       // 2764\n        // but if a parent animation is class-based then that's ok                                                     // 2765\n        if (!parentAnimationDetected) {                                                                                // 2766\n          var parentElementDisabled = disabledElementsLookup.get(parentElement);                                       // 2767\n                                                                                                                       // 2768\n          if (parentElementDisabled === true && elementDisabled !== false) {                                           // 2769\n            // disable animations if the user hasn't explicitly enabled animations on the                              // 2770\n            // current element                                                                                         // 2771\n            elementDisabled = true;                                                                                    // 2772\n            // element is disabled via parent element, no need to check anything else                                  // 2773\n            break;                                                                                                     // 2774\n          } else if (parentElementDisabled === false) {                                                                // 2775\n            elementDisabled = false;                                                                                   // 2776\n          }                                                                                                            // 2777\n          parentAnimationDetected = details.structural;                                                                // 2778\n        }                                                                                                              // 2779\n                                                                                                                       // 2780\n        if (isUndefined(animateChildren) || animateChildren === true) {                                                // 2781\n          var value = jqLite.data(parentElement, NG_ANIMATE_CHILDREN_DATA);                                            // 2782\n          if (isDefined(value)) {                                                                                      // 2783\n            animateChildren = value;                                                                                   // 2784\n          }                                                                                                            // 2785\n        }                                                                                                              // 2786\n                                                                                                                       // 2787\n        // there is no need to continue traversing at this point                                                       // 2788\n        if (parentAnimationDetected && animateChildren === false) break;                                               // 2789\n                                                                                                                       // 2790\n        if (!bodyElementDetected) {                                                                                    // 2791\n          // we also need to ensure that the element is or will be a part of the body element                          // 2792\n          // otherwise it is pointless to even issue an animation to be rendered                                       // 2793\n          bodyElementDetected = isMatchingElement(parentElement, bodyElement);                                         // 2794\n        }                                                                                                              // 2795\n                                                                                                                       // 2796\n        if (bodyElementDetected && rootElementDetected) {                                                              // 2797\n          // If both body and root have been found, any other checks are pointless,                                    // 2798\n          // as no animation data should live outside the application                                                  // 2799\n          break;                                                                                                       // 2800\n        }                                                                                                              // 2801\n                                                                                                                       // 2802\n        if (!rootElementDetected) {                                                                                    // 2803\n          // If no rootElement is detected, check if the parentElement is pinned to another element                    // 2804\n          parentHost = jqLite.data(parentElement, NG_ANIMATE_PIN_DATA);                                                // 2805\n          if (parentHost) {                                                                                            // 2806\n            // The pin target element becomes the next parent element                                                  // 2807\n            parentElement = getDomNode(parentHost);                                                                    // 2808\n            continue;                                                                                                  // 2809\n          }                                                                                                            // 2810\n        }                                                                                                              // 2811\n                                                                                                                       // 2812\n        parentElement = parentElement.parentNode;                                                                      // 2813\n      }                                                                                                                // 2814\n                                                                                                                       // 2815\n      var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;                  // 2816\n      return allowAnimation && rootElementDetected && bodyElementDetected;                                             // 2817\n    }                                                                                                                  // 2818\n                                                                                                                       // 2819\n    function markElementAnimationState(element, state, details) {                                                      // 2820\n      details = details || {};                                                                                         // 2821\n      details.state = state;                                                                                           // 2822\n                                                                                                                       // 2823\n      var node = getDomNode(element);                                                                                  // 2824\n      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);                                                                  // 2825\n                                                                                                                       // 2826\n      var oldValue = activeAnimationsLookup.get(node);                                                                 // 2827\n      var newValue = oldValue                                                                                          // 2828\n          ? extend(oldValue, details)                                                                                  // 2829\n          : details;                                                                                                   // 2830\n      activeAnimationsLookup.put(node, newValue);                                                                      // 2831\n    }                                                                                                                  // 2832\n  }];                                                                                                                  // 2833\n}];                                                                                                                    // 2834\n                                                                                                                       // 2835\nvar $$AnimationProvider = ['$animateProvider', function($animateProvider) {                                            // 2836\n  var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';                                                                          // 2837\n                                                                                                                       // 2838\n  var drivers = this.drivers = [];                                                                                     // 2839\n                                                                                                                       // 2840\n  var RUNNER_STORAGE_KEY = '$$animationRunner';                                                                        // 2841\n                                                                                                                       // 2842\n  function setRunner(element, runner) {                                                                                // 2843\n    element.data(RUNNER_STORAGE_KEY, runner);                                                                          // 2844\n  }                                                                                                                    // 2845\n                                                                                                                       // 2846\n  function removeRunner(element) {                                                                                     // 2847\n    element.removeData(RUNNER_STORAGE_KEY);                                                                            // 2848\n  }                                                                                                                    // 2849\n                                                                                                                       // 2850\n  function getRunner(element) {                                                                                        // 2851\n    return element.data(RUNNER_STORAGE_KEY);                                                                           // 2852\n  }                                                                                                                    // 2853\n                                                                                                                       // 2854\n  this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler',                // 2855\n       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$HashMap,   $$rAFScheduler) {               // 2856\n                                                                                                                       // 2857\n    var animationQueue = [];                                                                                           // 2858\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);                                                // 2859\n                                                                                                                       // 2860\n    function sortAnimations(animations) {                                                                              // 2861\n      var tree = { children: [] };                                                                                     // 2862\n      var i, lookup = new $$HashMap();                                                                                 // 2863\n                                                                                                                       // 2864\n      // this is done first beforehand so that the hashmap                                                             // 2865\n      // is filled with a list of the elements that will be animated                                                   // 2866\n      for (i = 0; i < animations.length; i++) {                                                                        // 2867\n        var animation = animations[i];                                                                                 // 2868\n        lookup.put(animation.domNode, animations[i] = {                                                                // 2869\n          domNode: animation.domNode,                                                                                  // 2870\n          fn: animation.fn,                                                                                            // 2871\n          children: []                                                                                                 // 2872\n        });                                                                                                            // 2873\n      }                                                                                                                // 2874\n                                                                                                                       // 2875\n      for (i = 0; i < animations.length; i++) {                                                                        // 2876\n        processNode(animations[i]);                                                                                    // 2877\n      }                                                                                                                // 2878\n                                                                                                                       // 2879\n      return flatten(tree);                                                                                            // 2880\n                                                                                                                       // 2881\n      function processNode(entry) {                                                                                    // 2882\n        if (entry.processed) return entry;                                                                             // 2883\n        entry.processed = true;                                                                                        // 2884\n                                                                                                                       // 2885\n        var elementNode = entry.domNode;                                                                               // 2886\n        var parentNode = elementNode.parentNode;                                                                       // 2887\n        lookup.put(elementNode, entry);                                                                                // 2888\n                                                                                                                       // 2889\n        var parentEntry;                                                                                               // 2890\n        while (parentNode) {                                                                                           // 2891\n          parentEntry = lookup.get(parentNode);                                                                        // 2892\n          if (parentEntry) {                                                                                           // 2893\n            if (!parentEntry.processed) {                                                                              // 2894\n              parentEntry = processNode(parentEntry);                                                                  // 2895\n            }                                                                                                          // 2896\n            break;                                                                                                     // 2897\n          }                                                                                                            // 2898\n          parentNode = parentNode.parentNode;                                                                          // 2899\n        }                                                                                                              // 2900\n                                                                                                                       // 2901\n        (parentEntry || tree).children.push(entry);                                                                    // 2902\n        return entry;                                                                                                  // 2903\n      }                                                                                                                // 2904\n                                                                                                                       // 2905\n      function flatten(tree) {                                                                                         // 2906\n        var result = [];                                                                                               // 2907\n        var queue = [];                                                                                                // 2908\n        var i;                                                                                                         // 2909\n                                                                                                                       // 2910\n        for (i = 0; i < tree.children.length; i++) {                                                                   // 2911\n          queue.push(tree.children[i]);                                                                                // 2912\n        }                                                                                                              // 2913\n                                                                                                                       // 2914\n        var remainingLevelEntries = queue.length;                                                                      // 2915\n        var nextLevelEntries = 0;                                                                                      // 2916\n        var row = [];                                                                                                  // 2917\n                                                                                                                       // 2918\n        for (i = 0; i < queue.length; i++) {                                                                           // 2919\n          var entry = queue[i];                                                                                        // 2920\n          if (remainingLevelEntries <= 0) {                                                                            // 2921\n            remainingLevelEntries = nextLevelEntries;                                                                  // 2922\n            nextLevelEntries = 0;                                                                                      // 2923\n            result.push(row);                                                                                          // 2924\n            row = [];                                                                                                  // 2925\n          }                                                                                                            // 2926\n          row.push(entry.fn);                                                                                          // 2927\n          entry.children.forEach(function(childEntry) {                                                                // 2928\n            nextLevelEntries++;                                                                                        // 2929\n            queue.push(childEntry);                                                                                    // 2930\n          });                                                                                                          // 2931\n          remainingLevelEntries--;                                                                                     // 2932\n        }                                                                                                              // 2933\n                                                                                                                       // 2934\n        if (row.length) {                                                                                              // 2935\n          result.push(row);                                                                                            // 2936\n        }                                                                                                              // 2937\n                                                                                                                       // 2938\n        return result;                                                                                                 // 2939\n      }                                                                                                                // 2940\n    }                                                                                                                  // 2941\n                                                                                                                       // 2942\n    // TODO(matsko): document the signature in a better way                                                            // 2943\n    return function(element, event, options) {                                                                         // 2944\n      options = prepareAnimationOptions(options);                                                                      // 2945\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;                                               // 2946\n                                                                                                                       // 2947\n      // there is no animation at the current moment, however                                                          // 2948\n      // these runner methods will get later updated with the                                                          // 2949\n      // methods leading into the driver's end/cancel methods                                                          // 2950\n      // for now they just stop the animation from starting                                                            // 2951\n      var runner = new $$AnimateRunner({                                                                               // 2952\n        end: function() { close(); },                                                                                  // 2953\n        cancel: function() { close(true); }                                                                            // 2954\n      });                                                                                                              // 2955\n                                                                                                                       // 2956\n      if (!drivers.length) {                                                                                           // 2957\n        close();                                                                                                       // 2958\n        return runner;                                                                                                 // 2959\n      }                                                                                                                // 2960\n                                                                                                                       // 2961\n      setRunner(element, runner);                                                                                      // 2962\n                                                                                                                       // 2963\n      var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));          // 2964\n      var tempClasses = options.tempClasses;                                                                           // 2965\n      if (tempClasses) {                                                                                               // 2966\n        classes += ' ' + tempClasses;                                                                                  // 2967\n        options.tempClasses = null;                                                                                    // 2968\n      }                                                                                                                // 2969\n                                                                                                                       // 2970\n      var prepareClassName;                                                                                            // 2971\n      if (isStructural) {                                                                                              // 2972\n        prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX;                                                       // 2973\n        $$jqLite.addClass(element, prepareClassName);                                                                  // 2974\n      }                                                                                                                // 2975\n                                                                                                                       // 2976\n      animationQueue.push({                                                                                            // 2977\n        // this data is used by the postDigest code and passed into                                                    // 2978\n        // the driver step function                                                                                    // 2979\n        element: element,                                                                                              // 2980\n        classes: classes,                                                                                              // 2981\n        event: event,                                                                                                  // 2982\n        structural: isStructural,                                                                                      // 2983\n        options: options,                                                                                              // 2984\n        beforeStart: beforeStart,                                                                                      // 2985\n        close: close                                                                                                   // 2986\n      });                                                                                                              // 2987\n                                                                                                                       // 2988\n      element.on('$destroy', handleDestroyedElement);                                                                  // 2989\n                                                                                                                       // 2990\n      // we only want there to be one function called within the post digest                                           // 2991\n      // block. This way we can group animations for all the animations that                                           // 2992\n      // were apart of the same postDigest flush call.                                                                 // 2993\n      if (animationQueue.length > 1) return runner;                                                                    // 2994\n                                                                                                                       // 2995\n      $rootScope.$$postDigest(function() {                                                                             // 2996\n        var animations = [];                                                                                           // 2997\n        forEach(animationQueue, function(entry) {                                                                      // 2998\n          // the element was destroyed early on which removed the runner                                               // 2999\n          // form its storage. This means we can't animate this element                                                // 3000\n          // at all and it already has been closed due to destruction.                                                 // 3001\n          if (getRunner(entry.element)) {                                                                              // 3002\n            animations.push(entry);                                                                                    // 3003\n          } else {                                                                                                     // 3004\n            entry.close();                                                                                             // 3005\n          }                                                                                                            // 3006\n        });                                                                                                            // 3007\n                                                                                                                       // 3008\n        // now any future animations will be in another postDigest                                                     // 3009\n        animationQueue.length = 0;                                                                                     // 3010\n                                                                                                                       // 3011\n        var groupedAnimations = groupAnimations(animations);                                                           // 3012\n        var toBeSortedAnimations = [];                                                                                 // 3013\n                                                                                                                       // 3014\n        forEach(groupedAnimations, function(animationEntry) {                                                          // 3015\n          toBeSortedAnimations.push({                                                                                  // 3016\n            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),           // 3017\n            fn: function triggerAnimationStart() {                                                                     // 3018\n              // it's important that we apply the `ng-animate` CSS class and the                                       // 3019\n              // temporary classes before we do any driver invoking since these                                        // 3020\n              // CSS classes may be required for proper CSS detection.                                                 // 3021\n              animationEntry.beforeStart();                                                                            // 3022\n                                                                                                                       // 3023\n              var startAnimationFn, closeFn = animationEntry.close;                                                    // 3024\n                                                                                                                       // 3025\n              // in the event that the element was removed before the digest runs or                                   // 3026\n              // during the RAF sequencing then we should not trigger the animation.                                   // 3027\n              var targetElement = animationEntry.anchors                                                               // 3028\n                  ? (animationEntry.from.element || animationEntry.to.element)                                         // 3029\n                  : animationEntry.element;                                                                            // 3030\n                                                                                                                       // 3031\n              if (getRunner(targetElement)) {                                                                          // 3032\n                var operation = invokeFirstDriver(animationEntry);                                                     // 3033\n                if (operation) {                                                                                       // 3034\n                  startAnimationFn = operation.start;                                                                  // 3035\n                }                                                                                                      // 3036\n              }                                                                                                        // 3037\n                                                                                                                       // 3038\n              if (!startAnimationFn) {                                                                                 // 3039\n                closeFn();                                                                                             // 3040\n              } else {                                                                                                 // 3041\n                var animationRunner = startAnimationFn();                                                              // 3042\n                animationRunner.done(function(status) {                                                                // 3043\n                  closeFn(!status);                                                                                    // 3044\n                });                                                                                                    // 3045\n                updateAnimationRunners(animationEntry, animationRunner);                                               // 3046\n              }                                                                                                        // 3047\n            }                                                                                                          // 3048\n          });                                                                                                          // 3049\n        });                                                                                                            // 3050\n                                                                                                                       // 3051\n        // we need to sort each of the animations in order of parent to child                                          // 3052\n        // relationships. This ensures that the child classes are applied at the                                       // 3053\n        // right time.                                                                                                 // 3054\n        $$rAFScheduler(sortAnimations(toBeSortedAnimations));                                                          // 3055\n      });                                                                                                              // 3056\n                                                                                                                       // 3057\n      return runner;                                                                                                   // 3058\n                                                                                                                       // 3059\n      // TODO(matsko): change to reference nodes                                                                       // 3060\n      function getAnchorNodes(node) {                                                                                  // 3061\n        var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';                                                                // 3062\n        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)                                                             // 3063\n              ? [node]                                                                                                 // 3064\n              : node.querySelectorAll(SELECTOR);                                                                       // 3065\n        var anchors = [];                                                                                              // 3066\n        forEach(items, function(node) {                                                                                // 3067\n          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);                                                           // 3068\n          if (attr && attr.length) {                                                                                   // 3069\n            anchors.push(node);                                                                                        // 3070\n          }                                                                                                            // 3071\n        });                                                                                                            // 3072\n        return anchors;                                                                                                // 3073\n      }                                                                                                                // 3074\n                                                                                                                       // 3075\n      function groupAnimations(animations) {                                                                           // 3076\n        var preparedAnimations = [];                                                                                   // 3077\n        var refLookup = {};                                                                                            // 3078\n        forEach(animations, function(animation, index) {                                                               // 3079\n          var element = animation.element;                                                                             // 3080\n          var node = getDomNode(element);                                                                              // 3081\n          var event = animation.event;                                                                                 // 3082\n          var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;                                                     // 3083\n          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];                                          // 3084\n                                                                                                                       // 3085\n          if (anchorNodes.length) {                                                                                    // 3086\n            var direction = enterOrMove ? 'to' : 'from';                                                               // 3087\n                                                                                                                       // 3088\n            forEach(anchorNodes, function(anchor) {                                                                    // 3089\n              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);                                                      // 3090\n              refLookup[key] = refLookup[key] || {};                                                                   // 3091\n              refLookup[key][direction] = {                                                                            // 3092\n                animationID: index,                                                                                    // 3093\n                element: jqLite(anchor)                                                                                // 3094\n              };                                                                                                       // 3095\n            });                                                                                                        // 3096\n          } else {                                                                                                     // 3097\n            preparedAnimations.push(animation);                                                                        // 3098\n          }                                                                                                            // 3099\n        });                                                                                                            // 3100\n                                                                                                                       // 3101\n        var usedIndicesLookup = {};                                                                                    // 3102\n        var anchorGroups = {};                                                                                         // 3103\n        forEach(refLookup, function(operations, key) {                                                                 // 3104\n          var from = operations.from;                                                                                  // 3105\n          var to = operations.to;                                                                                      // 3106\n                                                                                                                       // 3107\n          if (!from || !to) {                                                                                          // 3108\n            // only one of these is set therefore we can't have an                                                     // 3109\n            // anchor animation since all three pieces are required                                                    // 3110\n            var index = from ? from.animationID : to.animationID;                                                      // 3111\n            var indexKey = index.toString();                                                                           // 3112\n            if (!usedIndicesLookup[indexKey]) {                                                                        // 3113\n              usedIndicesLookup[indexKey] = true;                                                                      // 3114\n              preparedAnimations.push(animations[index]);                                                              // 3115\n            }                                                                                                          // 3116\n            return;                                                                                                    // 3117\n          }                                                                                                            // 3118\n                                                                                                                       // 3119\n          var fromAnimation = animations[from.animationID];                                                            // 3120\n          var toAnimation = animations[to.animationID];                                                                // 3121\n          var lookupKey = from.animationID.toString();                                                                 // 3122\n          if (!anchorGroups[lookupKey]) {                                                                              // 3123\n            var group = anchorGroups[lookupKey] = {                                                                    // 3124\n              structural: true,                                                                                        // 3125\n              beforeStart: function() {                                                                                // 3126\n                fromAnimation.beforeStart();                                                                           // 3127\n                toAnimation.beforeStart();                                                                             // 3128\n              },                                                                                                       // 3129\n              close: function() {                                                                                      // 3130\n                fromAnimation.close();                                                                                 // 3131\n                toAnimation.close();                                                                                   // 3132\n              },                                                                                                       // 3133\n              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),                             // 3134\n              from: fromAnimation,                                                                                     // 3135\n              to: toAnimation,                                                                                         // 3136\n              anchors: [] // TODO(matsko): change to reference nodes                                                   // 3137\n            };                                                                                                         // 3138\n                                                                                                                       // 3139\n            // the anchor animations require that the from and to elements both have at least                          // 3140\n            // one shared CSS class which effectively marries the two elements together to use                         // 3141\n            // the same animation driver and to properly sequence the anchor animation.                                // 3142\n            if (group.classes.length) {                                                                                // 3143\n              preparedAnimations.push(group);                                                                          // 3144\n            } else {                                                                                                   // 3145\n              preparedAnimations.push(fromAnimation);                                                                  // 3146\n              preparedAnimations.push(toAnimation);                                                                    // 3147\n            }                                                                                                          // 3148\n          }                                                                                                            // 3149\n                                                                                                                       // 3150\n          anchorGroups[lookupKey].anchors.push({                                                                       // 3151\n            'out': from.element, 'in': to.element                                                                      // 3152\n          });                                                                                                          // 3153\n        });                                                                                                            // 3154\n                                                                                                                       // 3155\n        return preparedAnimations;                                                                                     // 3156\n      }                                                                                                                // 3157\n                                                                                                                       // 3158\n      function cssClassesIntersection(a,b) {                                                                           // 3159\n        a = a.split(' ');                                                                                              // 3160\n        b = b.split(' ');                                                                                              // 3161\n        var matches = [];                                                                                              // 3162\n                                                                                                                       // 3163\n        for (var i = 0; i < a.length; i++) {                                                                           // 3164\n          var aa = a[i];                                                                                               // 3165\n          if (aa.substring(0,3) === 'ng-') continue;                                                                   // 3166\n                                                                                                                       // 3167\n          for (var j = 0; j < b.length; j++) {                                                                         // 3168\n            if (aa === b[j]) {                                                                                         // 3169\n              matches.push(aa);                                                                                        // 3170\n              break;                                                                                                   // 3171\n            }                                                                                                          // 3172\n          }                                                                                                            // 3173\n        }                                                                                                              // 3174\n                                                                                                                       // 3175\n        return matches.join(' ');                                                                                      // 3176\n      }                                                                                                                // 3177\n                                                                                                                       // 3178\n      function invokeFirstDriver(animationDetails) {                                                                   // 3179\n        // we loop in reverse order since the more general drivers (like CSS and JS)                                   // 3180\n        // may attempt more elements, but custom drivers are more particular                                           // 3181\n        for (var i = drivers.length - 1; i >= 0; i--) {                                                                // 3182\n          var driverName = drivers[i];                                                                                 // 3183\n          if (!$injector.has(driverName)) continue; // TODO(matsko): remove this check                                 // 3184\n                                                                                                                       // 3185\n          var factory = $injector.get(driverName);                                                                     // 3186\n          var driver = factory(animationDetails);                                                                      // 3187\n          if (driver) {                                                                                                // 3188\n            return driver;                                                                                             // 3189\n          }                                                                                                            // 3190\n        }                                                                                                              // 3191\n      }                                                                                                                // 3192\n                                                                                                                       // 3193\n      function beforeStart() {                                                                                         // 3194\n        element.addClass(NG_ANIMATE_CLASSNAME);                                                                        // 3195\n        if (tempClasses) {                                                                                             // 3196\n          $$jqLite.addClass(element, tempClasses);                                                                     // 3197\n        }                                                                                                              // 3198\n        if (prepareClassName) {                                                                                        // 3199\n          $$jqLite.removeClass(element, prepareClassName);                                                             // 3200\n          prepareClassName = null;                                                                                     // 3201\n        }                                                                                                              // 3202\n      }                                                                                                                // 3203\n                                                                                                                       // 3204\n      function updateAnimationRunners(animation, newRunner) {                                                          // 3205\n        if (animation.from && animation.to) {                                                                          // 3206\n          update(animation.from.element);                                                                              // 3207\n          update(animation.to.element);                                                                                // 3208\n        } else {                                                                                                       // 3209\n          update(animation.element);                                                                                   // 3210\n        }                                                                                                              // 3211\n                                                                                                                       // 3212\n        function update(element) {                                                                                     // 3213\n          getRunner(element).setHost(newRunner);                                                                       // 3214\n        }                                                                                                              // 3215\n      }                                                                                                                // 3216\n                                                                                                                       // 3217\n      function handleDestroyedElement() {                                                                              // 3218\n        var runner = getRunner(element);                                                                               // 3219\n        if (runner && (event !== 'leave' || !options.$$domOperationFired)) {                                           // 3220\n          runner.end();                                                                                                // 3221\n        }                                                                                                              // 3222\n      }                                                                                                                // 3223\n                                                                                                                       // 3224\n      function close(rejected) { // jshint ignore:line                                                                 // 3225\n        element.off('$destroy', handleDestroyedElement);                                                               // 3226\n        removeRunner(element);                                                                                         // 3227\n                                                                                                                       // 3228\n        applyAnimationClasses(element, options);                                                                       // 3229\n        applyAnimationStyles(element, options);                                                                        // 3230\n        options.domOperation();                                                                                        // 3231\n                                                                                                                       // 3232\n        if (tempClasses) {                                                                                             // 3233\n          $$jqLite.removeClass(element, tempClasses);                                                                  // 3234\n        }                                                                                                              // 3235\n                                                                                                                       // 3236\n        element.removeClass(NG_ANIMATE_CLASSNAME);                                                                     // 3237\n        runner.complete(!rejected);                                                                                    // 3238\n      }                                                                                                                // 3239\n    };                                                                                                                 // 3240\n  }];                                                                                                                  // 3241\n}];                                                                                                                    // 3242\n                                                                                                                       // 3243\n/**                                                                                                                    // 3244\n * @ngdoc directive                                                                                                    // 3245\n * @name ngAnimateSwap                                                                                                 // 3246\n * @restrict A                                                                                                         // 3247\n * @scope                                                                                                              // 3248\n *                                                                                                                     // 3249\n * @description                                                                                                        // 3250\n *                                                                                                                     // 3251\n * ngAnimateSwap is a animation-oriented directive that allows for the container to                                    // 3252\n * be removed and entered in whenever the associated expression changes. A                                             // 3253\n * common usecase for this directive is a rotating banner or slider component which                                    // 3254\n * contains one image being present at a time. When the active image changes                                           // 3255\n * then the old image will perform a `leave` animation and the new element                                             // 3256\n * will be inserted via an `enter` animation.                                                                          // 3257\n *                                                                                                                     // 3258\n * @animations                                                                                                         // 3259\n * | Animation                        | Occurs                               |                                         // 3260\n * |----------------------------------|--------------------------------------|                                         // 3261\n * | {@link ng.$animate#enter enter}  | when the new element is inserted to the DOM  |                                 // 3262\n * | {@link ng.$animate#leave leave}  | when the old element is removed from the DOM |                                 // 3263\n *                                                                                                                     // 3264\n * @example                                                                                                            // 3265\n * <example name=\"ngAnimateSwap-directive\" module=\"ngAnimateSwapExample\"                                               // 3266\n *          deps=\"angular-animate.js\"                                                                                  // 3267\n *          animations=\"true\" fixBase=\"true\">                                                                          // 3268\n *   <file name=\"index.html\">                                                                                          // 3269\n *     <div class=\"container\" ng-controller=\"AppCtrl\">                                                                 // 3270\n *       <div ng-animate-swap=\"number\" class=\"cell swap-animation\" ng-class=\"colorClass(number)\">                      // 3271\n *         {{ number }}                                                                                                // 3272\n *       </div>                                                                                                        // 3273\n *     </div>                                                                                                          // 3274\n *   </file>                                                                                                           // 3275\n *   <file name=\"script.js\">                                                                                           // 3276\n *     angular.module('ngAnimateSwapExample', ['ngAnimate'])                                                           // 3277\n *       .controller('AppCtrl', ['$scope', '$interval', function($scope, $interval) {                                  // 3278\n *         $scope.number = 0;                                                                                          // 3279\n *         $interval(function() {                                                                                      // 3280\n *           $scope.number++;                                                                                          // 3281\n *         }, 1000);                                                                                                   // 3282\n *                                                                                                                     // 3283\n *         var colors = ['red','blue','green','yellow','orange'];                                                      // 3284\n *         $scope.colorClass = function(number) {                                                                      // 3285\n *           return colors[number % colors.length];                                                                    // 3286\n *         };                                                                                                          // 3287\n *       }]);                                                                                                          // 3288\n *   </file>                                                                                                           // 3289\n *  <file name=\"animations.css\">                                                                                       // 3290\n *  .container {                                                                                                       // 3291\n *    height:250px;                                                                                                    // 3292\n *    width:250px;                                                                                                     // 3293\n *    position:relative;                                                                                               // 3294\n *    overflow:hidden;                                                                                                 // 3295\n *    border:2px solid black;                                                                                          // 3296\n *  }                                                                                                                  // 3297\n *  .container .cell {                                                                                                 // 3298\n *    font-size:150px;                                                                                                 // 3299\n *    text-align:center;                                                                                               // 3300\n *    line-height:250px;                                                                                               // 3301\n *    position:absolute;                                                                                               // 3302\n *    top:0;                                                                                                           // 3303\n *    left:0;                                                                                                          // 3304\n *    right:0;                                                                                                         // 3305\n *    border-bottom:2px solid black;                                                                                   // 3306\n *  }                                                                                                                  // 3307\n *  .swap-animation.ng-enter, .swap-animation.ng-leave {                                                               // 3308\n *    transition:0.5s linear all;                                                                                      // 3309\n *  }                                                                                                                  // 3310\n *  .swap-animation.ng-enter {                                                                                         // 3311\n *    top:-250px;                                                                                                      // 3312\n *  }                                                                                                                  // 3313\n *  .swap-animation.ng-enter-active {                                                                                  // 3314\n *    top:0px;                                                                                                         // 3315\n *  }                                                                                                                  // 3316\n *  .swap-animation.ng-leave {                                                                                         // 3317\n *    top:0px;                                                                                                         // 3318\n *  }                                                                                                                  // 3319\n *  .swap-animation.ng-leave-active {                                                                                  // 3320\n *    top:250px;                                                                                                       // 3321\n *  }                                                                                                                  // 3322\n *  .red { background:red; }                                                                                           // 3323\n *  .green { background:green; }                                                                                       // 3324\n *  .blue { background:blue; }                                                                                         // 3325\n *  .yellow { background:yellow; }                                                                                     // 3326\n *  .orange { background:orange; }                                                                                     // 3327\n *  </file>                                                                                                            // 3328\n * </example>                                                                                                          // 3329\n */                                                                                                                    // 3330\nvar ngAnimateSwapDirective = ['$animate', '$rootScope', function($animate, $rootScope) {                               // 3331\n  return {                                                                                                             // 3332\n    restrict: 'A',                                                                                                     // 3333\n    transclude: 'element',                                                                                             // 3334\n    terminal: true,                                                                                                    // 3335\n    priority: 600, // we use 600 here to ensure that the directive is caught before others                             // 3336\n    link: function(scope, $element, attrs, ctrl, $transclude) {                                                        // 3337\n      var previousElement, previousScope;                                                                              // 3338\n      scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function(value) {                                    // 3339\n        if (previousElement) {                                                                                         // 3340\n          $animate.leave(previousElement);                                                                             // 3341\n        }                                                                                                              // 3342\n        if (previousScope) {                                                                                           // 3343\n          previousScope.$destroy();                                                                                    // 3344\n          previousScope = null;                                                                                        // 3345\n        }                                                                                                              // 3346\n        if (value || value === 0) {                                                                                    // 3347\n          previousScope = scope.$new();                                                                                // 3348\n          $transclude(previousScope, function(element) {                                                               // 3349\n            previousElement = element;                                                                                 // 3350\n            $animate.enter(element, null, $element);                                                                   // 3351\n          });                                                                                                          // 3352\n        }                                                                                                              // 3353\n      });                                                                                                              // 3354\n    }                                                                                                                  // 3355\n  };                                                                                                                   // 3356\n}];                                                                                                                    // 3357\n                                                                                                                       // 3358\n/* global angularAnimateModule: true,                                                                                  // 3359\n                                                                                                                       // 3360\n   ngAnimateSwapDirective,                                                                                             // 3361\n   $$AnimateAsyncRunFactory,                                                                                           // 3362\n   $$rAFSchedulerFactory,                                                                                              // 3363\n   $$AnimateChildrenDirective,                                                                                         // 3364\n   $$AnimateQueueProvider,                                                                                             // 3365\n   $$AnimationProvider,                                                                                                // 3366\n   $AnimateCssProvider,                                                                                                // 3367\n   $$AnimateCssDriverProvider,                                                                                         // 3368\n   $$AnimateJsProvider,                                                                                                // 3369\n   $$AnimateJsDriverProvider,                                                                                          // 3370\n*/                                                                                                                     // 3371\n                                                                                                                       // 3372\n/**                                                                                                                    // 3373\n * @ngdoc module                                                                                                       // 3374\n * @name ngAnimate                                                                                                     // 3375\n * @description                                                                                                        // 3376\n *                                                                                                                     // 3377\n * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via\n * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an Angular app.\n *                                                                                                                     // 3380\n * <div doc-module-components=\"ngAnimate\"></div>                                                                       // 3381\n *                                                                                                                     // 3382\n * # Usage                                                                                                             // 3383\n * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based\n * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For\n * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within\n * the HTML element that the animation will be triggered on.                                                           // 3387\n *                                                                                                                     // 3388\n * ## Directive Support                                                                                                // 3389\n * The following directives are \"animation aware\":                                                                     // 3390\n *                                                                                                                     // 3391\n * | Directive                                                                                                | Supported Animations                                                     |\n * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|\n * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |\n * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |\n * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |\n * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |\n * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |\n * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |\n * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |\n * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |\n * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |\n * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |\n *                                                                                                                     // 3404\n * (More information can be found by visiting each the documentation associated with each directive.)                  // 3405\n *                                                                                                                     // 3406\n * ## CSS-based Animations                                                                                             // 3407\n *                                                                                                                     // 3408\n * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML\n * and CSS code we can create an animation that will be picked up by Angular when an the underlying directive performs an operation.\n *                                                                                                                     // 3411\n * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:                  // 3412\n *                                                                                                                     // 3413\n * ```html                                                                                                             // 3414\n * <div ng-if=\"bool\" class=\"fade\">                                                                                     // 3415\n *    Fade me in out                                                                                                   // 3416\n * </div>                                                                                                              // 3417\n * <button ng-click=\"bool=true\">Fade In!</button>                                                                      // 3418\n * <button ng-click=\"bool=false\">Fade Out!</button>                                                                    // 3419\n * ```                                                                                                                 // 3420\n *                                                                                                                     // 3421\n * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:                // 3422\n *                                                                                                                     // 3423\n * ```css                                                                                                              // 3424\n * /&#42; The starting CSS styles for the enter animation &#42;/                                                       // 3425\n * .fade.ng-enter {                                                                                                    // 3426\n *   transition:0.5s linear all;                                                                                       // 3427\n *   opacity:0;                                                                                                        // 3428\n * }                                                                                                                   // 3429\n *                                                                                                                     // 3430\n * /&#42; The finishing CSS styles for the enter animation &#42;/                                                      // 3431\n * .fade.ng-enter.ng-enter-active {                                                                                    // 3432\n *   opacity:1;                                                                                                        // 3433\n * }                                                                                                                   // 3434\n * ```                                                                                                                 // 3435\n *                                                                                                                     // 3436\n * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two\n * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition\n * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.\n *                                                                                                                     // 3440\n * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:\n *                                                                                                                     // 3442\n * ```css                                                                                                              // 3443\n * /&#42; now the element will fade out before it is removed from the DOM &#42;/                                       // 3444\n * .fade.ng-leave {                                                                                                    // 3445\n *   transition:0.5s linear all;                                                                                       // 3446\n *   opacity:1;                                                                                                        // 3447\n * }                                                                                                                   // 3448\n * .fade.ng-leave.ng-leave-active {                                                                                    // 3449\n *   opacity:0;                                                                                                        // 3450\n * }                                                                                                                   // 3451\n * ```                                                                                                                 // 3452\n *                                                                                                                     // 3453\n * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:      // 3454\n *                                                                                                                     // 3455\n * ```css                                                                                                              // 3456\n * /&#42; there is no need to define anything inside of the destination                                                // 3457\n * CSS class since the keyframe will take charge of the animation &#42;/                                               // 3458\n * .fade.ng-leave {                                                                                                    // 3459\n *   animation: my_fade_animation 0.5s linear;                                                                         // 3460\n *   -webkit-animation: my_fade_animation 0.5s linear;                                                                 // 3461\n * }                                                                                                                   // 3462\n *                                                                                                                     // 3463\n * @keyframes my_fade_animation {                                                                                      // 3464\n *   from { opacity:1; }                                                                                               // 3465\n *   to { opacity:0; }                                                                                                 // 3466\n * }                                                                                                                   // 3467\n *                                                                                                                     // 3468\n * @-webkit-keyframes my_fade_animation {                                                                              // 3469\n *   from { opacity:1; }                                                                                               // 3470\n *   to { opacity:0; }                                                                                                 // 3471\n * }                                                                                                                   // 3472\n * ```                                                                                                                 // 3473\n *                                                                                                                     // 3474\n * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.         // 3475\n *                                                                                                                     // 3476\n * ### CSS Class-based Animations                                                                                      // 3477\n *                                                                                                                     // 3478\n * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different\n * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added\n * and removed.                                                                                                        // 3481\n *                                                                                                                     // 3482\n * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:\n *                                                                                                                     // 3484\n * ```html                                                                                                             // 3485\n * <div ng-show=\"bool\" class=\"fade\">                                                                                   // 3486\n *   Show and hide me                                                                                                  // 3487\n * </div>                                                                                                              // 3488\n * <button ng-click=\"bool=true\">Toggle</button>                                                                        // 3489\n *                                                                                                                     // 3490\n * <style>                                                                                                             // 3491\n * .fade.ng-hide {                                                                                                     // 3492\n *   transition:0.5s linear all;                                                                                       // 3493\n *   opacity:0;                                                                                                        // 3494\n * }                                                                                                                   // 3495\n * </style>                                                                                                            // 3496\n * ```                                                                                                                 // 3497\n *                                                                                                                     // 3498\n * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since\n * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.             // 3500\n *                                                                                                                     // 3501\n * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation\n * with CSS styles.                                                                                                    // 3503\n *                                                                                                                     // 3504\n * ```html                                                                                                             // 3505\n * <div ng-class=\"{on:onOff}\" class=\"highlight\">                                                                       // 3506\n *   Highlight this box                                                                                                // 3507\n * </div>                                                                                                              // 3508\n * <button ng-click=\"onOff=!onOff\">Toggle</button>                                                                     // 3509\n *                                                                                                                     // 3510\n * <style>                                                                                                             // 3511\n * .highlight {                                                                                                        // 3512\n *   transition:0.5s linear all;                                                                                       // 3513\n * }                                                                                                                   // 3514\n * .highlight.on-add {                                                                                                 // 3515\n *   background:white;                                                                                                 // 3516\n * }                                                                                                                   // 3517\n * .highlight.on {                                                                                                     // 3518\n *   background:yellow;                                                                                                // 3519\n * }                                                                                                                   // 3520\n * .highlight.on-remove {                                                                                              // 3521\n *   background:black;                                                                                                 // 3522\n * }                                                                                                                   // 3523\n * </style>                                                                                                            // 3524\n * ```                                                                                                                 // 3525\n *                                                                                                                     // 3526\n * We can also make use of CSS keyframes by placing them within the CSS classes.                                       // 3527\n *                                                                                                                     // 3528\n *                                                                                                                     // 3529\n * ### CSS Staggering Animations                                                                                       // 3530\n * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a\n * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be\n * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for      // 3533\n * the animation. The style property expected within the stagger class can either be a **transition-delay** or an      // 3534\n * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).         // 3535\n *                                                                                                                     // 3536\n * ```css                                                                                                              // 3537\n * .my-animation.ng-enter {                                                                                            // 3538\n *   /&#42; standard transition code &#42;/                                                                            // 3539\n *   transition: 1s linear all;                                                                                        // 3540\n *   opacity:0;                                                                                                        // 3541\n * }                                                                                                                   // 3542\n * .my-animation.ng-enter-stagger {                                                                                    // 3543\n *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/                                // 3544\n *   transition-delay: 0.1s;                                                                                           // 3545\n *                                                                                                                     // 3546\n *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate                                                 // 3547\n *     to not accidentally inherit a delay property from another CSS class &#42;/                                      // 3548\n *   transition-duration: 0s;                                                                                          // 3549\n * }                                                                                                                   // 3550\n * .my-animation.ng-enter.ng-enter-active {                                                                            // 3551\n *   /&#42; standard transition styles &#42;/                                                                          // 3552\n *   opacity:1;                                                                                                        // 3553\n * }                                                                                                                   // 3554\n * ```                                                                                                                 // 3555\n *                                                                                                                     // 3556\n * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations\n * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this\n * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation\n * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.   // 3560\n *                                                                                                                     // 3561\n * The following code will issue the **ng-leave-stagger** event on the element provided:                               // 3562\n *                                                                                                                     // 3563\n * ```js                                                                                                               // 3564\n * var kids = parent.children();                                                                                       // 3565\n *                                                                                                                     // 3566\n * $animate.leave(kids[0]); //stagger index=0                                                                          // 3567\n * $animate.leave(kids[1]); //stagger index=1                                                                          // 3568\n * $animate.leave(kids[2]); //stagger index=2                                                                          // 3569\n * $animate.leave(kids[3]); //stagger index=3                                                                          // 3570\n * $animate.leave(kids[4]); //stagger index=4                                                                          // 3571\n *                                                                                                                     // 3572\n * window.requestAnimationFrame(function() {                                                                           // 3573\n *   //stagger has reset itself                                                                                        // 3574\n *   $animate.leave(kids[5]); //stagger index=0                                                                        // 3575\n *   $animate.leave(kids[6]); //stagger index=1                                                                        // 3576\n *                                                                                                                     // 3577\n *   $scope.$digest();                                                                                                 // 3578\n * });                                                                                                                 // 3579\n * ```                                                                                                                 // 3580\n *                                                                                                                     // 3581\n * Stagger animations are currently only supported within CSS-defined animations.                                      // 3582\n *                                                                                                                     // 3583\n * ### The `ng-animate` CSS class                                                                                      // 3584\n *                                                                                                                     // 3585\n * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.\n * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).\n *                                                                                                                     // 3588\n * Therefore, animations can be applied to an element using this temporary class directly via CSS.                     // 3589\n *                                                                                                                     // 3590\n * ```css                                                                                                              // 3591\n * .zipper.ng-animate {                                                                                                // 3592\n *   transition:0.5s linear all;                                                                                       // 3593\n * }                                                                                                                   // 3594\n * .zipper.ng-enter {                                                                                                  // 3595\n *   opacity:0;                                                                                                        // 3596\n * }                                                                                                                   // 3597\n * .zipper.ng-enter.ng-enter-active {                                                                                  // 3598\n *   opacity:1;                                                                                                        // 3599\n * }                                                                                                                   // 3600\n * .zipper.ng-leave {                                                                                                  // 3601\n *   opacity:1;                                                                                                        // 3602\n * }                                                                                                                   // 3603\n * .zipper.ng-leave.ng-leave-active {                                                                                  // 3604\n *   opacity:0;                                                                                                        // 3605\n * }                                                                                                                   // 3606\n * ```                                                                                                                 // 3607\n *                                                                                                                     // 3608\n * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove\n * the CSS class once an animation has completed.)                                                                     // 3610\n *                                                                                                                     // 3611\n *                                                                                                                     // 3612\n * ### The `ng-[event]-prepare` class                                                                                  // 3613\n *                                                                                                                     // 3614\n * This is a special class that can be used to prevent unwanted flickering / flash of content before                   // 3615\n * the actual animation starts. The class is added as soon as an animation is initialized, but removed                 // 3616\n * before the actual animation starts (after waiting for a $digest).                                                   // 3617\n * It is also only added for *structural* animations (`enter`, `move`, and `leave`).                                   // 3618\n *                                                                                                                     // 3619\n * In practice, flickering can appear when nesting elements with structural animations such as `ngIf`                  // 3620\n * into elements that have class-based animations such as `ngClass`.                                                   // 3621\n *                                                                                                                     // 3622\n * ```html                                                                                                             // 3623\n * <div ng-class=\"{red: myProp}\">                                                                                      // 3624\n *   <div ng-class=\"{blue: myProp}\">                                                                                   // 3625\n *     <div class=\"message\" ng-if=\"myProp\"></div>                                                                      // 3626\n *   </div>                                                                                                            // 3627\n * </div>                                                                                                              // 3628\n * ```                                                                                                                 // 3629\n *                                                                                                                     // 3630\n * It is possible that during the `enter` animation, the `.message` div will be briefly visible before it starts animating.\n * In that case, you can add styles to the CSS that make sure the element stays hidden before the animation starts:    // 3632\n *                                                                                                                     // 3633\n * ```css                                                                                                              // 3634\n * .message.ng-enter-prepare {                                                                                         // 3635\n *   opacity: 0;                                                                                                       // 3636\n * }                                                                                                                   // 3637\n *                                                                                                                     // 3638\n * ```                                                                                                                 // 3639\n *                                                                                                                     // 3640\n * ## JavaScript-based Animations                                                                                      // 3641\n *                                                                                                                     // 3642\n * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared\n * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the\n * `module.animation()` module function we can register the animation.                                                 // 3645\n *                                                                                                                     // 3646\n * Let's see an example of a enter/leave animation using `ngRepeat`:                                                   // 3647\n *                                                                                                                     // 3648\n * ```html                                                                                                             // 3649\n * <div ng-repeat=\"item in items\" class=\"slide\">                                                                       // 3650\n *   {{ item }}                                                                                                        // 3651\n * </div>                                                                                                              // 3652\n * ```                                                                                                                 // 3653\n *                                                                                                                     // 3654\n * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:\n *                                                                                                                     // 3656\n * ```js                                                                                                               // 3657\n * myModule.animation('.slide', [function() {                                                                          // 3658\n *   return {                                                                                                          // 3659\n *     // make note that other events (like addClass/removeClass)                                                      // 3660\n *     // have different function input parameters                                                                     // 3661\n *     enter: function(element, doneFn) {                                                                              // 3662\n *       jQuery(element).fadeIn(1000, doneFn);                                                                         // 3663\n *                                                                                                                     // 3664\n *       // remember to call doneFn so that angular                                                                    // 3665\n *       // knows that the animation has concluded                                                                     // 3666\n *     },                                                                                                              // 3667\n *                                                                                                                     // 3668\n *     move: function(element, doneFn) {                                                                               // 3669\n *       jQuery(element).fadeIn(1000, doneFn);                                                                         // 3670\n *     },                                                                                                              // 3671\n *                                                                                                                     // 3672\n *     leave: function(element, doneFn) {                                                                              // 3673\n *       jQuery(element).fadeOut(1000, doneFn);                                                                        // 3674\n *     }                                                                                                               // 3675\n *   }                                                                                                                 // 3676\n * }]);                                                                                                                // 3677\n * ```                                                                                                                 // 3678\n *                                                                                                                     // 3679\n * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as\n * greensock.js and velocity.js.                                                                                       // 3681\n *                                                                                                                     // 3682\n * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define\n * our animations inside of the same registered animation, however, the function input arguments are a bit different:  // 3684\n *                                                                                                                     // 3685\n * ```html                                                                                                             // 3686\n * <div ng-class=\"color\" class=\"colorful\">                                                                             // 3687\n *   this box is moody                                                                                                 // 3688\n * </div>                                                                                                              // 3689\n * <button ng-click=\"color='red'\">Change to red</button>                                                               // 3690\n * <button ng-click=\"color='blue'\">Change to blue</button>                                                             // 3691\n * <button ng-click=\"color='green'\">Change to green</button>                                                           // 3692\n * ```                                                                                                                 // 3693\n *                                                                                                                     // 3694\n * ```js                                                                                                               // 3695\n * myModule.animation('.colorful', [function() {                                                                       // 3696\n *   return {                                                                                                          // 3697\n *     addClass: function(element, className, doneFn) {                                                                // 3698\n *       // do some cool animation and call the doneFn                                                                 // 3699\n *     },                                                                                                              // 3700\n *     removeClass: function(element, className, doneFn) {                                                             // 3701\n *       // do some cool animation and call the doneFn                                                                 // 3702\n *     },                                                                                                              // 3703\n *     setClass: function(element, addedClass, removedClass, doneFn) {                                                 // 3704\n *       // do some cool animation and call the doneFn                                                                 // 3705\n *     }                                                                                                               // 3706\n *   }                                                                                                                 // 3707\n * }]);                                                                                                                // 3708\n * ```                                                                                                                 // 3709\n *                                                                                                                     // 3710\n * ## CSS + JS Animations Together                                                                                     // 3711\n *                                                                                                                     // 3712\n * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,\n * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking\n * charge of the animation**:                                                                                          // 3715\n *                                                                                                                     // 3716\n * ```html                                                                                                             // 3717\n * <div ng-if=\"bool\" class=\"slide\">                                                                                    // 3718\n *   Slide in and out                                                                                                  // 3719\n * </div>                                                                                                              // 3720\n * ```                                                                                                                 // 3721\n *                                                                                                                     // 3722\n * ```js                                                                                                               // 3723\n * myModule.animation('.slide', [function() {                                                                          // 3724\n *   return {                                                                                                          // 3725\n *     enter: function(element, doneFn) {                                                                              // 3726\n *       jQuery(element).slideIn(1000, doneFn);                                                                        // 3727\n *     }                                                                                                               // 3728\n *   }                                                                                                                 // 3729\n * }]);                                                                                                                // 3730\n * ```                                                                                                                 // 3731\n *                                                                                                                     // 3732\n * ```css                                                                                                              // 3733\n * .slide.ng-enter {                                                                                                   // 3734\n *   transition:0.5s linear all;                                                                                       // 3735\n *   transform:translateY(-100px);                                                                                     // 3736\n * }                                                                                                                   // 3737\n * .slide.ng-enter.ng-enter-active {                                                                                   // 3738\n *   transform:translateY(0);                                                                                          // 3739\n * }                                                                                                                   // 3740\n * ```                                                                                                                 // 3741\n *                                                                                                                     // 3742\n * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the\n * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from\n * our own JS-based animation code:                                                                                    // 3745\n *                                                                                                                     // 3746\n * ```js                                                                                                               // 3747\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {                                                // 3748\n *   return {                                                                                                          // 3749\n *     enter: function(element) {                                                                                      // 3750\n*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.                                          // 3751\n *       return $animateCss(element, {                                                                                 // 3752\n *         event: 'enter',                                                                                             // 3753\n *         structural: true                                                                                            // 3754\n *       });                                                                                                           // 3755\n *     }                                                                                                               // 3756\n *   }                                                                                                                 // 3757\n * }]);                                                                                                                // 3758\n * ```                                                                                                                 // 3759\n *                                                                                                                     // 3760\n * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.\n *                                                                                                                     // 3762\n * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or\n * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that\n * data into `$animateCss` directly:                                                                                   // 3765\n *                                                                                                                     // 3766\n * ```js                                                                                                               // 3767\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {                                                // 3768\n *   return {                                                                                                          // 3769\n *     enter: function(element) {                                                                                      // 3770\n *       return $animateCss(element, {                                                                                 // 3771\n *         event: 'enter',                                                                                             // 3772\n *         structural: true,                                                                                           // 3773\n *         addClass: 'maroon-setting',                                                                                 // 3774\n *         from: { height:0 },                                                                                         // 3775\n *         to: { height: 200 }                                                                                         // 3776\n *       });                                                                                                           // 3777\n *     }                                                                                                               // 3778\n *   }                                                                                                                 // 3779\n * }]);                                                                                                                // 3780\n * ```                                                                                                                 // 3781\n *                                                                                                                     // 3782\n * Now we can fill in the rest via our transition CSS code:                                                            // 3783\n *                                                                                                                     // 3784\n * ```css                                                                                                              // 3785\n * /&#42; the transition tells ngAnimate to make the animation happen &#42;/                                           // 3786\n * .slide.ng-enter { transition:0.5s linear all; }                                                                     // 3787\n *                                                                                                                     // 3788\n * /&#42; this extra CSS class will be absorbed into the transition                                                    // 3789\n * since the $animateCss code is adding the class &#42;/                                                               // 3790\n * .maroon-setting { background:red; }                                                                                 // 3791\n * ```                                                                                                                 // 3792\n *                                                                                                                     // 3793\n * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.\n *                                                                                                                     // 3795\n * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.         // 3796\n *                                                                                                                     // 3797\n * ## Animation Anchoring (via `ng-animate-ref`)                                                                       // 3798\n *                                                                                                                     // 3799\n * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between                          // 3800\n * structural areas of an application (like views) by pairing up elements using an attribute                           // 3801\n * called `ng-animate-ref`.                                                                                            // 3802\n *                                                                                                                     // 3803\n * Let's say for example we have two views that are managed by `ng-view` and we want to show                           // 3804\n * that there is a relationship between two components situated in within these views. By using the                    // 3805\n * `ng-animate-ref` attribute we can identify that the two components are paired together and we                       // 3806\n * can then attach an animation, which is triggered when the view changes.                                             // 3807\n *                                                                                                                     // 3808\n * Say for example we have the following template code:                                                                // 3809\n *                                                                                                                     // 3810\n * ```html                                                                                                             // 3811\n * <!-- index.html -->                                                                                                 // 3812\n * <div ng-view class=\"view-animation\">                                                                                // 3813\n * </div>                                                                                                              // 3814\n *                                                                                                                     // 3815\n * <!-- home.html -->                                                                                                  // 3816\n * <a href=\"#/banner-page\">                                                                                            // 3817\n *   <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">                                                   // 3818\n * </a>                                                                                                                // 3819\n *                                                                                                                     // 3820\n * <!-- banner-page.html -->                                                                                           // 3821\n * <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">                                                     // 3822\n * ```                                                                                                                 // 3823\n *                                                                                                                     // 3824\n * Now, when the view changes (once the link is clicked), ngAnimate will examine the                                   // 3825\n * HTML contents to see if there is a match reference between any components in the view                               // 3826\n * that is leaving and the view that is entering. It will scan both the view which is being                            // 3827\n * removed (leave) and inserted (enter) to see if there are any paired DOM elements that                               // 3828\n * contain a matching ref value.                                                                                       // 3829\n *                                                                                                                     // 3830\n * The two images match since they share the same ref value. ngAnimate will now create a                               // 3831\n * transport element (which is a clone of the first image element) and it will then attempt                            // 3832\n * to animate to the position of the second image element in the next view. For the animation to                       // 3833\n * work a special CSS class called `ng-anchor` will be added to the transported element.                               // 3834\n *                                                                                                                     // 3835\n * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then                                      // 3836\n * ngAnimate will handle the entire transition for us as well as the addition and removal of                           // 3837\n * any changes of CSS classes between the elements:                                                                    // 3838\n *                                                                                                                     // 3839\n * ```css                                                                                                              // 3840\n * .banner.ng-anchor {                                                                                                 // 3841\n *   /&#42; this animation will last for 1 second since there are                                                      // 3842\n *          two phases to the animation (an `in` and an `out` phase) &#42;/                                            // 3843\n *   transition:0.5s linear all;                                                                                       // 3844\n * }                                                                                                                   // 3845\n * ```                                                                                                                 // 3846\n *                                                                                                                     // 3847\n * We also **must** include animations for the views that are being entered and removed                                // 3848\n * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).                         // 3849\n *                                                                                                                     // 3850\n * ```css                                                                                                              // 3851\n * .view-animation.ng-enter, .view-animation.ng-leave {                                                                // 3852\n *   transition:0.5s linear all;                                                                                       // 3853\n *   position:fixed;                                                                                                   // 3854\n *   left:0;                                                                                                           // 3855\n *   top:0;                                                                                                            // 3856\n *   width:100%;                                                                                                       // 3857\n * }                                                                                                                   // 3858\n * .view-animation.ng-enter {                                                                                          // 3859\n *   transform:translateX(100%);                                                                                       // 3860\n * }                                                                                                                   // 3861\n * .view-animation.ng-leave,                                                                                           // 3862\n * .view-animation.ng-enter.ng-enter-active {                                                                          // 3863\n *   transform:translateX(0%);                                                                                         // 3864\n * }                                                                                                                   // 3865\n * .view-animation.ng-leave.ng-leave-active {                                                                          // 3866\n *   transform:translateX(-100%);                                                                                      // 3867\n * }                                                                                                                   // 3868\n * ```                                                                                                                 // 3869\n *                                                                                                                     // 3870\n * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:          // 3871\n * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away             // 3872\n * from its origin. Once that animation is over then the `in` stage occurs which animates the                          // 3873\n * element to its destination. The reason why there are two animations is to give enough time                          // 3874\n * for the enter animation on the new element to be ready.                                                             // 3875\n *                                                                                                                     // 3876\n * The example above sets up a transition for both the in and out phases, but we can also target the out or            // 3877\n * in phases directly via `ng-anchor-out` and `ng-anchor-in`.                                                          // 3878\n *                                                                                                                     // 3879\n * ```css                                                                                                              // 3880\n * .banner.ng-anchor-out {                                                                                             // 3881\n *   transition: 0.5s linear all;                                                                                      // 3882\n *                                                                                                                     // 3883\n *   /&#42; the scale will be applied during the out animation,                                                        // 3884\n *          but will be animated away when the in animation runs &#42;/                                                // 3885\n *   transform: scale(1.2);                                                                                            // 3886\n * }                                                                                                                   // 3887\n *                                                                                                                     // 3888\n * .banner.ng-anchor-in {                                                                                              // 3889\n *   transition: 1s linear all;                                                                                        // 3890\n * }                                                                                                                   // 3891\n * ```                                                                                                                 // 3892\n *                                                                                                                     // 3893\n *                                                                                                                     // 3894\n *                                                                                                                     // 3895\n *                                                                                                                     // 3896\n * ### Anchoring Demo                                                                                                  // 3897\n *                                                                                                                     // 3898\n  <example module=\"anchoringExample\"                                                                                   // 3899\n           name=\"anchoringExample\"                                                                                     // 3900\n           id=\"anchoringExample\"                                                                                       // 3901\n           deps=\"angular-animate.js;angular-route.js\"                                                                  // 3902\n           animations=\"true\">                                                                                          // 3903\n    <file name=\"index.html\">                                                                                           // 3904\n      <a href=\"#/\">Home</a>                                                                                            // 3905\n      <hr />                                                                                                           // 3906\n      <div class=\"view-container\">                                                                                     // 3907\n        <div ng-view class=\"view\"></div>                                                                               // 3908\n      </div>                                                                                                           // 3909\n    </file>                                                                                                            // 3910\n    <file name=\"script.js\">                                                                                            // 3911\n      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])                                                     // 3912\n        .config(['$routeProvider', function($routeProvider) {                                                          // 3913\n          $routeProvider.when('/', {                                                                                   // 3914\n            templateUrl: 'home.html',                                                                                  // 3915\n            controller: 'HomeController as home'                                                                       // 3916\n          });                                                                                                          // 3917\n          $routeProvider.when('/profile/:id', {                                                                        // 3918\n            templateUrl: 'profile.html',                                                                               // 3919\n            controller: 'ProfileController as profile'                                                                 // 3920\n          });                                                                                                          // 3921\n        }])                                                                                                            // 3922\n        .run(['$rootScope', function($rootScope) {                                                                     // 3923\n          $rootScope.records = [                                                                                       // 3924\n            { id:1, title: \"Miss Beulah Roob\" },                                                                       // 3925\n            { id:2, title: \"Trent Morissette\" },                                                                       // 3926\n            { id:3, title: \"Miss Ava Pouros\" },                                                                        // 3927\n            { id:4, title: \"Rod Pouros\" },                                                                             // 3928\n            { id:5, title: \"Abdul Rice\" },                                                                             // 3929\n            { id:6, title: \"Laurie Rutherford Sr.\" },                                                                  // 3930\n            { id:7, title: \"Nakia McLaughlin\" },                                                                       // 3931\n            { id:8, title: \"Jordon Blanda DVM\" },                                                                      // 3932\n            { id:9, title: \"Rhoda Hand\" },                                                                             // 3933\n            { id:10, title: \"Alexandrea Sauer\" }                                                                       // 3934\n          ];                                                                                                           // 3935\n        }])                                                                                                            // 3936\n        .controller('HomeController', [function() {                                                                    // 3937\n          //empty                                                                                                      // 3938\n        }])                                                                                                            // 3939\n        .controller('ProfileController', ['$rootScope', '$routeParams', function($rootScope, $routeParams) {           // 3940\n          var index = parseInt($routeParams.id, 10);                                                                   // 3941\n          var record = $rootScope.records[index - 1];                                                                  // 3942\n                                                                                                                       // 3943\n          this.title = record.title;                                                                                   // 3944\n          this.id = record.id;                                                                                         // 3945\n        }]);                                                                                                           // 3946\n    </file>                                                                                                            // 3947\n    <file name=\"home.html\">                                                                                            // 3948\n      <h2>Welcome to the home page</h1>                                                                                // 3949\n      <p>Please click on an element</p>                                                                                // 3950\n      <a class=\"record\"                                                                                                // 3951\n         ng-href=\"#/profile/{{ record.id }}\"                                                                           // 3952\n         ng-animate-ref=\"{{ record.id }}\"                                                                              // 3953\n         ng-repeat=\"record in records\">                                                                                // 3954\n        {{ record.title }}                                                                                             // 3955\n      </a>                                                                                                             // 3956\n    </file>                                                                                                            // 3957\n    <file name=\"profile.html\">                                                                                         // 3958\n      <div class=\"profile record\" ng-animate-ref=\"{{ profile.id }}\">                                                   // 3959\n        {{ profile.title }}                                                                                            // 3960\n      </div>                                                                                                           // 3961\n    </file>                                                                                                            // 3962\n    <file name=\"animations.css\">                                                                                       // 3963\n      .record {                                                                                                        // 3964\n        display:block;                                                                                                 // 3965\n        font-size:20px;                                                                                                // 3966\n      }                                                                                                                // 3967\n      .profile {                                                                                                       // 3968\n        background:black;                                                                                              // 3969\n        color:white;                                                                                                   // 3970\n        font-size:100px;                                                                                               // 3971\n      }                                                                                                                // 3972\n      .view-container {                                                                                                // 3973\n        position:relative;                                                                                             // 3974\n      }                                                                                                                // 3975\n      .view-container > .view.ng-animate {                                                                             // 3976\n        position:absolute;                                                                                             // 3977\n        top:0;                                                                                                         // 3978\n        left:0;                                                                                                        // 3979\n        width:100%;                                                                                                    // 3980\n        min-height:500px;                                                                                              // 3981\n      }                                                                                                                // 3982\n      .view.ng-enter, .view.ng-leave,                                                                                  // 3983\n      .record.ng-anchor {                                                                                              // 3984\n        transition:0.5s linear all;                                                                                    // 3985\n      }                                                                                                                // 3986\n      .view.ng-enter {                                                                                                 // 3987\n        transform:translateX(100%);                                                                                    // 3988\n      }                                                                                                                // 3989\n      .view.ng-enter.ng-enter-active, .view.ng-leave {                                                                 // 3990\n        transform:translateX(0%);                                                                                      // 3991\n      }                                                                                                                // 3992\n      .view.ng-leave.ng-leave-active {                                                                                 // 3993\n        transform:translateX(-100%);                                                                                   // 3994\n      }                                                                                                                // 3995\n      .record.ng-anchor-out {                                                                                          // 3996\n        background:red;                                                                                                // 3997\n      }                                                                                                                // 3998\n    </file>                                                                                                            // 3999\n  </example>                                                                                                           // 4000\n *                                                                                                                     // 4001\n * ### How is the element transported?                                                                                 // 4002\n *                                                                                                                     // 4003\n * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting\n * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element\n * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The\n * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match    // 4007\n * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied\n * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class\n * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element\n * will become visible since the shim class will be removed.                                                           // 4011\n *                                                                                                                     // 4012\n * ### How is the morphing handled?                                                                                    // 4013\n *                                                                                                                     // 4014\n * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out         // 4015\n * what CSS classes differ between the starting element and the destination element. These different CSS classes       // 4016\n * will be added/removed on the anchor element and a transition will be applied (the transition that is provided       // 4017\n * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will         // 4018\n * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that      // 4019\n * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since     // 4020\n * the cloned element is placed inside of root element which is likely close to the body element).                     // 4021\n *                                                                                                                     // 4022\n * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.        // 4023\n *                                                                                                                     // 4024\n *                                                                                                                     // 4025\n * ## Using $animate in your directive code                                                                            // 4026\n *                                                                                                                     // 4027\n * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?\n * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's\n * imagine we have a greeting box that shows and hides itself when the data changes                                    // 4030\n *                                                                                                                     // 4031\n * ```html                                                                                                             // 4032\n * <greeting-box active=\"onOrOff\">Hi there</greeting-box>                                                              // 4033\n * ```                                                                                                                 // 4034\n *                                                                                                                     // 4035\n * ```js                                                                                                               // 4036\n * ngModule.directive('greetingBox', ['$animate', function($animate) {                                                 // 4037\n *   return function(scope, element, attrs) {                                                                          // 4038\n *     attrs.$observe('active', function(value) {                                                                      // 4039\n *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');                               // 4040\n *     });                                                                                                             // 4041\n *   });                                                                                                               // 4042\n * }]);                                                                                                                // 4043\n * ```                                                                                                                 // 4044\n *                                                                                                                     // 4045\n * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element\n * in our HTML code then we can trigger a CSS or JS animation to happen.                                               // 4047\n *                                                                                                                     // 4048\n * ```css                                                                                                              // 4049\n * /&#42; normally we would create a CSS class to reference on the element &#42;/                                      // 4050\n * greeting-box.on { transition:0.5s linear all; background:green; color:white; }                                      // 4051\n * ```                                                                                                                 // 4052\n *                                                                                                                     // 4053\n * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's\n * possible be sure to visit the {@link ng.$animate $animate service API page}.                                        // 4055\n *                                                                                                                     // 4056\n *                                                                                                                     // 4057\n * ## Callbacks and Promises                                                                                           // 4058\n *                                                                                                                     // 4059\n * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger\n * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has\n * ended by chaining onto the returned promise that animation method returns.                                          // 4062\n *                                                                                                                     // 4063\n * ```js                                                                                                               // 4064\n * // somewhere within the depths of the directive                                                                     // 4065\n * $animate.enter(element, parent).then(function() {                                                                   // 4066\n *   //the animation has completed                                                                                     // 4067\n * });                                                                                                                 // 4068\n * ```                                                                                                                 // 4069\n *                                                                                                                     // 4070\n * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case\n * anymore.)                                                                                                           // 4072\n *                                                                                                                     // 4073\n * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering\n * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view   // 4075\n * routing controller to hook into that:                                                                               // 4076\n *                                                                                                                     // 4077\n * ```js                                                                                                               // 4078\n * ngModule.controller('HomePageController', ['$animate', function($animate) {                                         // 4079\n *   $animate.on('enter', ngViewElement, function(element) {                                                           // 4080\n *     // the animation for this route has completed                                                                   // 4081\n *   }]);                                                                                                              // 4082\n * }])                                                                                                                 // 4083\n * ```                                                                                                                 // 4084\n *                                                                                                                     // 4085\n * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)\n */                                                                                                                    // 4087\n                                                                                                                       // 4088\n/**                                                                                                                    // 4089\n * @ngdoc service                                                                                                      // 4090\n * @name $animate                                                                                                      // 4091\n * @kind object                                                                                                        // 4092\n *                                                                                                                     // 4093\n * @description                                                                                                        // 4094\n * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.                         // 4095\n *                                                                                                                     // 4096\n * Click here {@link ng.$animate to learn more about animations with `$animate`}.                                      // 4097\n */                                                                                                                    // 4098\nangular.module('ngAnimate', [])                                                                                        // 4099\n  .directive('ngAnimateSwap', ngAnimateSwapDirective)                                                                  // 4100\n                                                                                                                       // 4101\n  .directive('ngAnimateChildren', $$AnimateChildrenDirective)                                                          // 4102\n  .factory('$$rAFScheduler', $$rAFSchedulerFactory)                                                                    // 4103\n                                                                                                                       // 4104\n  .provider('$$animateQueue', $$AnimateQueueProvider)                                                                  // 4105\n  .provider('$$animation', $$AnimationProvider)                                                                        // 4106\n                                                                                                                       // 4107\n  .provider('$animateCss', $AnimateCssProvider)                                                                        // 4108\n  .provider('$$animateCssDriver', $$AnimateCssDriverProvider)                                                          // 4109\n                                                                                                                       // 4110\n  .provider('$$animateJs', $$AnimateJsProvider)                                                                        // 4111\n  .provider('$$animateJsDriver', $$AnimateJsDriverProvider);                                                           // 4112\n                                                                                                                       // 4113\n                                                                                                                       // 4114\n})(window, window.angular);                                                                                            // 4115\n                                                                                                                       // 4116\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage['angular:angular-animate'] = {};\n\n})();\n","servePath":"/packages/angular_angular-animate.js"}]